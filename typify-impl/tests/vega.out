#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AggregateTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<AggregateTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cross: Option<AggregateTransformCross>,
    #[serde(default = "defaults::aggregate_transform_drop")]
    pub drop: AggregateTransformDrop,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<AggregateTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<AggregateTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<AggregateTransformKey>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ops: Option<AggregateTransformOps>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: AggregateTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformAs {
    #[educe(Default)]
    Variant0(Vec<AggregateTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformCross {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformDrop {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformFields {
    #[educe(Default)]
    Variant0(Vec<AggregateTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformFieldsVariant0Item {
    #[educe(Default)]
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<AggregateTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformKey {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformOps {
    #[educe(Default)]
    Variant0(Vec<AggregateTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AggregateTransformOpsVariant0Item {
    #[educe(Default)]
    Variant0(AggregateTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AggregateTransformOpsVariant0ItemVariant0 {
    #[educe(Default)]
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl ToString for AggregateTransformOpsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for AggregateTransformOpsVariant0ItemVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AggregateTransformType {
    #[educe(Default)]
    #[serde(rename = "aggregate")]
    Aggregate,
}
impl ToString for AggregateTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Aggregate => "aggregate".to_string(),
        }
    }
}
impl std::str::FromStr for AggregateTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "aggregate" => Ok(Self::Aggregate),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AggregateTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AggregateTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AlignValue {
    #[educe(Default)]
    Variant0(Vec<AlignValueVariant0Item>),
    Variant1(AlignValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: AlignValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AlignValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AlignValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AlignValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AlignValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AlignValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AlignValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ToString for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AlignValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AlignValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AlignValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AlignValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AlignValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AlignValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: AlignValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AlignValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AlignValueVariant1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ToString for AlignValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AlignValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlignValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AlignValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AlignValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnchorValue {
    #[educe(Default)]
    Variant0(Vec<AnchorValueVariant0Item>),
    Variant1(AnchorValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: AnchorValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AnchorValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AnchorValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AnchorValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AnchorValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AnchorValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnchorValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ToString for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AnchorValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AnchorValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AnchorValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AnchorValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AnchorValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnchorValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: AnchorValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AnchorValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AnchorValueVariant1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ToString for AnchorValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for AnchorValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnchorValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnchorValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnchorValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnyValue {
    #[educe(Default)]
    Variant0(Vec<AnyValueVariant0Item>),
    Variant1(AnyValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: AnyValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AnyValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AnyValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AnyValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AnyValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AnyValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnyValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: serde_json::Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AnyValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AnyValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AnyValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AnyValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AnyValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnyValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: serde_json::Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AnyValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AnyValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AnyValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ArrayOrSignal {
    #[educe(Default)]
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ArrayValue {
    #[educe(Default)]
    Variant0(Vec<ArrayValueVariant0Item>),
    Variant1(ArrayValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: ArrayValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: ArrayValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<ArrayValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<ArrayValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<ArrayValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<ArrayValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ArrayValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: Vec<serde_json::Value>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: ArrayValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<ArrayValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<ArrayValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<ArrayValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<ArrayValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ArrayValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: Vec<serde_json::Value>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: ArrayValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ArrayValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ArrayValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Autosize {
    #[educe(Default)]
    Variant0(AutosizeVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        contains: Option<AutosizeVariant1Contains>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        resize: Option<bool>,
        #[serde(rename = "type")]
        type_: AutosizeVariant1Type,
    },
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AutosizeVariant0 {
    #[educe(Default)]
    #[serde(rename = "pad")]
    Pad,
    #[serde(rename = "fit")]
    Fit,
    #[serde(rename = "fit-x")]
    FitX,
    #[serde(rename = "fit-y")]
    FitY,
    #[serde(rename = "none")]
    None,
}
impl ToString for AutosizeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Pad => "pad".to_string(),
            Self::Fit => "fit".to_string(),
            Self::FitX => "fit-x".to_string(),
            Self::FitY => "fit-y".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for AutosizeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pad" => Ok(Self::Pad),
            "fit" => Ok(Self::Fit),
            "fit-x" => Ok(Self::FitX),
            "fit-y" => Ok(Self::FitY),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AutosizeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AutosizeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AutosizeVariant1Contains {
    #[educe(Default)]
    #[serde(rename = "content")]
    Content,
    #[serde(rename = "padding")]
    Padding,
}
impl ToString for AutosizeVariant1Contains {
    fn to_string(&self) -> String {
        match *self {
            Self::Content => "content".to_string(),
            Self::Padding => "padding".to_string(),
        }
    }
}
impl std::str::FromStr for AutosizeVariant1Contains {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "content" => Ok(Self::Content),
            "padding" => Ok(Self::Padding),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AutosizeVariant1Contains {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AutosizeVariant1Contains {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AutosizeVariant1Type {
    #[educe(Default)]
    #[serde(rename = "pad")]
    Pad,
    #[serde(rename = "fit")]
    Fit,
    #[serde(rename = "fit-x")]
    FitX,
    #[serde(rename = "fit-y")]
    FitY,
    #[serde(rename = "none")]
    None,
}
impl ToString for AutosizeVariant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Pad => "pad".to_string(),
            Self::Fit => "fit".to_string(),
            Self::FitX => "fit-x".to_string(),
            Self::FitY => "fit-y".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for AutosizeVariant1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pad" => Ok(Self::Pad),
            "fit" => Ok(Self::Fit),
            "fit-x" => Ok(Self::FitX),
            "fit-y" => Ok(Self::FitY),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AutosizeVariant1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AutosizeVariant1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Axis {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(
        rename = "bandPosition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub band_position: Option<AxisBandPosition>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<bool>,
    #[serde(rename = "domainCap", default, skip_serializing_if = "Option::is_none")]
    pub domain_cap: Option<AxisDomainCap>,
    #[serde(
        rename = "domainColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_color: Option<AxisDomainColor>,
    #[serde(
        rename = "domainDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_dash: Option<AxisDomainDash>,
    #[serde(
        rename = "domainDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_dash_offset: Option<AxisDomainDashOffset>,
    #[serde(
        rename = "domainOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_opacity: Option<AxisDomainOpacity>,
    #[serde(
        rename = "domainWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_width: Option<AxisDomainWidth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<AxisEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<AxisFormat>,
    #[serde(
        rename = "formatType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub format_type: Option<AxisFormatType>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grid: Option<bool>,
    #[serde(rename = "gridCap", default, skip_serializing_if = "Option::is_none")]
    pub grid_cap: Option<AxisGridCap>,
    #[serde(rename = "gridColor", default, skip_serializing_if = "Option::is_none")]
    pub grid_color: Option<AxisGridColor>,
    #[serde(rename = "gridDash", default, skip_serializing_if = "Option::is_none")]
    pub grid_dash: Option<AxisGridDash>,
    #[serde(
        rename = "gridDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub grid_dash_offset: Option<AxisGridDashOffset>,
    #[serde(
        rename = "gridOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub grid_opacity: Option<AxisGridOpacity>,
    #[serde(rename = "gridScale", default, skip_serializing_if = "Option::is_none")]
    pub grid_scale: Option<String>,
    #[serde(rename = "gridWidth", default, skip_serializing_if = "Option::is_none")]
    pub grid_width: Option<AxisGridWidth>,
    #[serde(
        rename = "labelAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_align: Option<AxisLabelAlign>,
    #[serde(
        rename = "labelAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_angle: Option<AxisLabelAngle>,
    #[serde(
        rename = "labelBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_baseline: Option<AxisLabelBaseline>,
    #[serde(
        rename = "labelBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_bound: Option<AxisLabelBound>,
    #[serde(
        rename = "labelColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_color: Option<AxisLabelColor>,
    #[serde(
        rename = "labelFlush",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_flush: Option<AxisLabelFlush>,
    #[serde(
        rename = "labelFlushOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_flush_offset: Option<NumberOrSignal>,
    #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
    pub label_font: Option<AxisLabelFont>,
    #[serde(
        rename = "labelFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_size: Option<AxisLabelFontSize>,
    #[serde(
        rename = "labelFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_style: Option<AxisLabelFontStyle>,
    #[serde(
        rename = "labelFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_weight: Option<AxisLabelFontWeight>,
    #[serde(
        rename = "labelLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_limit: Option<AxisLabelLimit>,
    #[serde(
        rename = "labelLineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_line_height: Option<AxisLabelLineHeight>,
    #[serde(
        rename = "labelOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_offset: Option<AxisLabelOffset>,
    #[serde(
        rename = "labelOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_opacity: Option<AxisLabelOpacity>,
    #[serde(
        rename = "labelOverlap",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_overlap: Option<LabelOverlap>,
    #[serde(
        rename = "labelPadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_padding: Option<AxisLabelPadding>,
    #[serde(
        rename = "labelSeparation",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_separation: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<bool>,
    #[serde(rename = "maxExtent", default, skip_serializing_if = "Option::is_none")]
    pub max_extent: Option<AxisMaxExtent>,
    #[serde(rename = "minExtent", default, skip_serializing_if = "Option::is_none")]
    pub min_extent: Option<AxisMinExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<AxisOffset>,
    pub orient: AxisOrient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<AxisPosition>,
    pub scale: String,
    #[serde(rename = "tickBand", default, skip_serializing_if = "Option::is_none")]
    pub tick_band: Option<TickBand>,
    #[serde(rename = "tickCap", default, skip_serializing_if = "Option::is_none")]
    pub tick_cap: Option<AxisTickCap>,
    #[serde(rename = "tickColor", default, skip_serializing_if = "Option::is_none")]
    pub tick_color: Option<AxisTickColor>,
    #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
    pub tick_count: Option<TickCount>,
    #[serde(rename = "tickDash", default, skip_serializing_if = "Option::is_none")]
    pub tick_dash: Option<AxisTickDash>,
    #[serde(
        rename = "tickDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_dash_offset: Option<AxisTickDashOffset>,
    #[serde(rename = "tickExtra", default, skip_serializing_if = "Option::is_none")]
    pub tick_extra: Option<BooleanOrSignal>,
    #[serde(
        rename = "tickMinStep",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_min_step: Option<NumberOrSignal>,
    #[serde(
        rename = "tickOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_offset: Option<AxisTickOffset>,
    #[serde(
        rename = "tickOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_opacity: Option<AxisTickOpacity>,
    #[serde(rename = "tickRound", default, skip_serializing_if = "Option::is_none")]
    pub tick_round: Option<AxisTickRound>,
    #[serde(rename = "tickSize", default, skip_serializing_if = "Option::is_none")]
    pub tick_size: Option<AxisTickSize>,
    #[serde(rename = "tickWidth", default, skip_serializing_if = "Option::is_none")]
    pub tick_width: Option<AxisTickWidth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ticks: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<TextOrSignal>,
    #[serde(
        rename = "titleAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_align: Option<AxisTitleAlign>,
    #[serde(
        rename = "titleAnchor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_anchor: Option<AxisTitleAnchor>,
    #[serde(
        rename = "titleAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_angle: Option<AxisTitleAngle>,
    #[serde(
        rename = "titleBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_baseline: Option<AxisTitleBaseline>,
    #[serde(
        rename = "titleColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_color: Option<AxisTitleColor>,
    #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
    pub title_font: Option<AxisTitleFont>,
    #[serde(
        rename = "titleFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_size: Option<AxisTitleFontSize>,
    #[serde(
        rename = "titleFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_style: Option<AxisTitleFontStyle>,
    #[serde(
        rename = "titleFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_weight: Option<AxisTitleFontWeight>,
    #[serde(
        rename = "titleLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_limit: Option<AxisTitleLimit>,
    #[serde(
        rename = "titleLineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_line_height: Option<AxisTitleLineHeight>,
    #[serde(
        rename = "titleOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_opacity: Option<AxisTitleOpacity>,
    #[serde(
        rename = "titlePadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_padding: Option<AxisTitlePadding>,
    #[serde(rename = "titleX", default, skip_serializing_if = "Option::is_none")]
    pub title_x: Option<AxisTitleX>,
    #[serde(rename = "titleY", default, skip_serializing_if = "Option::is_none")]
    pub title_y: Option<AxisTitleY>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<AxisTranslate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ArrayOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zindex: Option<f64>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisBandPosition {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisDomainCap {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisDomainColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisDomainDash {
    #[educe(Default)]
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisDomainDashOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisDomainOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisDomainWidth {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AxisEncode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub axis: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grid: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ticks: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum AxisFormat {
    #[educe(Default)]
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisFormatType {
    #[educe(Default)]
    Variant0(AxisFormatTypeVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AxisFormatTypeVariant0 {
    #[educe(Default)]
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ToString for AxisFormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for AxisFormatTypeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisFormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisFormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisGridCap {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisGridColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisGridDash {
    #[educe(Default)]
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisGridDashOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisGridOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisGridWidth {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelAlign {
    #[educe(Default)]
    Variant0(AxisLabelAlignVariant0),
    Variant1(AlignValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AxisLabelAlignVariant0 {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ToString for AxisLabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AxisLabelAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisLabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisLabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelAngle {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelBaseline {
    #[educe(Default)]
    Variant0(AxisLabelBaselineVariant0),
    Variant1(BaselineValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AxisLabelBaselineVariant0 {
    #[educe(Default)]
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ToString for AxisLabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for AxisLabelBaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisLabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisLabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelBound {
    #[educe(Default)]
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelFlush {
    #[educe(Default)]
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelFont {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelFontSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelFontStyle {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelFontWeight {
    #[educe(Default)]
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelLimit {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelLineHeight {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisLabelPadding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisMaxExtent {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisMinExtent {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisOrient {
    #[educe(Default)]
    Variant0(AxisOrientVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AxisOrientVariant0 {
    #[educe(Default)]
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
}
impl ToString for AxisOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
        }
    }
}
impl std::str::FromStr for AxisOrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisPosition {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTickCap {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTickColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTickDash {
    #[educe(Default)]
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTickDashOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTickOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTickOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTickRound {
    #[educe(Default)]
    Variant0(bool),
    Variant1(BooleanValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTickSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTickWidth {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleAlign {
    #[educe(Default)]
    Variant0(AxisTitleAlignVariant0),
    Variant1(AlignValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AxisTitleAlignVariant0 {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ToString for AxisTitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AxisTitleAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisTitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisTitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleAnchor {
    #[educe(Default)]
    Variant0(Option<AxisTitleAnchorVariant0>),
    Variant1(AnchorValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AxisTitleAnchorVariant0 {
    #[educe(Default)]
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ToString for AxisTitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for AxisTitleAnchorVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisTitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisTitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleAngle {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleBaseline {
    #[educe(Default)]
    Variant0(AxisTitleBaselineVariant0),
    Variant1(BaselineValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum AxisTitleBaselineVariant0 {
    #[educe(Default)]
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ToString for AxisTitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for AxisTitleBaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisTitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisTitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleFont {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleFontSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleFontStyle {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleFontWeight {
    #[educe(Default)]
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleLimit {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleLineHeight {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitlePadding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleX {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTitleY {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum AxisTranslate {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Background(pub StringOrSignal);
impl std::ops::Deref for Background {
    type Target = StringOrSignal;
    fn deref(&self) -> &StringOrSignal {
        &self.0
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum BaseColorValue {
    #[educe(Default)]
    Variant0(BaseColorValueVariant0),
    Variant1 {
        value: LinearGradient,
    },
    Variant2 {
        value: RadialGradient,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<f64>,
        gradient: Field,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        start: Vec<f64>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        stop: Vec<f64>,
    },
    Variant4 {
        color: BaseColorValueVariant4Color,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaseColorValueVariant0 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BaseColorValueVariant0Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaseColorValueVariant0Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BaseColorValueVariant0Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BaseColorValueVariant0Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BaseColorValueVariant0Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BaseColorValueVariant0Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BaseColorValueVariant0Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: Option<String>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BaseColorValueVariant0Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BaseColorValueVariant0Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaseColorValueVariant0Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaseColorValueVariant0Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaseColorValueVariant0Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BaseColorValueVariant4Color {
    #[educe(Default)]
    Rgb(ColorRgb),
    Hsl(ColorHsl),
    Lab(ColorLab),
    Hcl(ColorHcl),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BaselineValue {
    #[educe(Default)]
    Variant0(Vec<BaselineValueVariant0Item>),
    Variant1(BaselineValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: BaselineValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BaselineValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BaselineValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BaselineValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BaselineValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BaselineValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BaselineValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
}
impl ToString for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
        }
    }
}
impl std::str::FromStr for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BaselineValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BaselineValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BaselineValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BaselineValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BaselineValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BaselineValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: BaselineValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BaselineValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BaselineValueVariant1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
}
impl ToString for BaselineValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
        }
    }
}
impl std::str::FromStr for BaselineValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BaselineValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaselineValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BaselineValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BaselineValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BinTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anchor: Option<BinTransformAnchor>,
    #[serde(rename = "as", default = "defaults::bin_transform_as")]
    pub as_: BinTransformAs,
    #[serde(default = "defaults::bin_transform_base")]
    pub base: BinTransformBase,
    #[serde(default = "defaults::bin_transform_divide")]
    pub divide: BinTransformDivide,
    pub extent: BinTransformExtent,
    pub field: BinTransformField,
    #[serde(default = "defaults::bin_transform_interval")]
    pub interval: BinTransformInterval,
    #[serde(default = "defaults::bin_transform_maxbins")]
    pub maxbins: BinTransformMaxbins,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minstep: Option<BinTransformMinstep>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<BinTransformName>,
    #[serde(default = "defaults::bin_transform_nice")]
    pub nice: BinTransformNice,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub span: Option<BinTransformSpan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<BinTransformStep>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<BinTransformSteps>,
    #[serde(rename = "type")]
    pub type_: BinTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformAnchor {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformAs {
    #[educe(Default)]
    Variant0(BinTransformAsVariant0, BinTransformAsVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformBase {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformDivide {
    #[educe(Default)]
    Variant0(Vec<BinTransformDivideVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformDivideVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformExtent {
    #[educe(Default)]
    Variant0(BinTransformExtentVariant0, BinTransformExtentVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformExtentVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformInterval {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformMaxbins {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformMinstep {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformName {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformNice {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformSpan {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformStep {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformSteps {
    #[educe(Default)]
    Variant0(Vec<BinTransformStepsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BinTransformStepsVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BinTransformType {
    #[educe(Default)]
    #[serde(rename = "bin")]
    Bin,
}
impl ToString for BinTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bin => "bin".to_string(),
        }
    }
}
impl std::str::FromStr for BinTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "bin" => Ok(Self::Bin),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BinTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BinTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Bind {
    #[educe(Default)]
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant0Input,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant1Input,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        labels: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        options: Vec<serde_json::Value>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant2Input,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        max: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        min: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        step: Option<f64>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant3Input,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        element: Element,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        event: Option<String>,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BindVariant0Input {
    #[educe(Default)]
    #[serde(rename = "checkbox")]
    Checkbox,
}
impl ToString for BindVariant0Input {
    fn to_string(&self) -> String {
        match *self {
            Self::Checkbox => "checkbox".to_string(),
        }
    }
}
impl std::str::FromStr for BindVariant0Input {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "checkbox" => Ok(Self::Checkbox),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BindVariant0Input {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BindVariant0Input {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BindVariant1Input {
    #[educe(Default)]
    #[serde(rename = "radio")]
    Radio,
    #[serde(rename = "select")]
    Select,
}
impl ToString for BindVariant1Input {
    fn to_string(&self) -> String {
        match *self {
            Self::Radio => "radio".to_string(),
            Self::Select => "select".to_string(),
        }
    }
}
impl std::str::FromStr for BindVariant1Input {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "radio" => Ok(Self::Radio),
            "select" => Ok(Self::Select),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BindVariant1Input {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BindVariant1Input {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BindVariant2Input {
    #[educe(Default)]
    #[serde(rename = "range")]
    Range,
}
impl ToString for BindVariant2Input {
    fn to_string(&self) -> String {
        match *self {
            Self::Range => "range".to_string(),
        }
    }
}
impl std::str::FromStr for BindVariant2Input {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "range" => Ok(Self::Range),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BindVariant2Input {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BindVariant2Input {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BindVariant3Input(String);
impl std::ops::Deref for BindVariant3Input {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::convert::TryFrom<String> for BindVariant3Input {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        if [
            "checkbox".to_string(),
            "radio".to_string(),
            "range".to_string(),
            "select".to_string(),
        ]
        .contains(&value)
        {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BlendValue {
    #[educe(Default)]
    Variant0(Vec<BlendValueVariant0Item>),
    Variant1(BlendValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: BlendValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BlendValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BlendValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "multiply")]
    Multiply,
    #[serde(rename = "screen")]
    Screen,
    #[serde(rename = "overlay")]
    Overlay,
    #[serde(rename = "darken")]
    Darken,
    #[serde(rename = "lighten")]
    Lighten,
    #[serde(rename = "color-dodge")]
    ColorDodge,
    #[serde(rename = "color-burn")]
    ColorBurn,
    #[serde(rename = "hard-light")]
    HardLight,
    #[serde(rename = "soft-light")]
    SoftLight,
    #[serde(rename = "difference")]
    Difference,
    #[serde(rename = "exclusion")]
    Exclusion,
    #[serde(rename = "hue")]
    Hue,
    #[serde(rename = "saturation")]
    Saturation,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "luminosity")]
    Luminosity,
}
impl ToString for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Multiply => "multiply".to_string(),
            Self::Screen => "screen".to_string(),
            Self::Overlay => "overlay".to_string(),
            Self::Darken => "darken".to_string(),
            Self::Lighten => "lighten".to_string(),
            Self::ColorDodge => "color-dodge".to_string(),
            Self::ColorBurn => "color-burn".to_string(),
            Self::HardLight => "hard-light".to_string(),
            Self::SoftLight => "soft-light".to_string(),
            Self::Difference => "difference".to_string(),
            Self::Exclusion => "exclusion".to_string(),
            Self::Hue => "hue".to_string(),
            Self::Saturation => "saturation".to_string(),
            Self::Color => "color".to_string(),
            Self::Luminosity => "luminosity".to_string(),
        }
    }
}
impl std::str::FromStr for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "multiply" => Ok(Self::Multiply),
            "screen" => Ok(Self::Screen),
            "overlay" => Ok(Self::Overlay),
            "darken" => Ok(Self::Darken),
            "lighten" => Ok(Self::Lighten),
            "color-dodge" => Ok(Self::ColorDodge),
            "color-burn" => Ok(Self::ColorBurn),
            "hard-light" => Ok(Self::HardLight),
            "soft-light" => Ok(Self::SoftLight),
            "difference" => Ok(Self::Difference),
            "exclusion" => Ok(Self::Exclusion),
            "hue" => Ok(Self::Hue),
            "saturation" => Ok(Self::Saturation),
            "color" => Ok(Self::Color),
            "luminosity" => Ok(Self::Luminosity),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BlendValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BlendValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BlendValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BlendValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BlendValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BlendValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: Option<BlendValueVariant1Subtype1Subtype0Variant1Value>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BlendValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum BlendValueVariant1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "multiply")]
    Multiply,
    #[serde(rename = "screen")]
    Screen,
    #[serde(rename = "overlay")]
    Overlay,
    #[serde(rename = "darken")]
    Darken,
    #[serde(rename = "lighten")]
    Lighten,
    #[serde(rename = "color-dodge")]
    ColorDodge,
    #[serde(rename = "color-burn")]
    ColorBurn,
    #[serde(rename = "hard-light")]
    HardLight,
    #[serde(rename = "soft-light")]
    SoftLight,
    #[serde(rename = "difference")]
    Difference,
    #[serde(rename = "exclusion")]
    Exclusion,
    #[serde(rename = "hue")]
    Hue,
    #[serde(rename = "saturation")]
    Saturation,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "luminosity")]
    Luminosity,
}
impl ToString for BlendValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Multiply => "multiply".to_string(),
            Self::Screen => "screen".to_string(),
            Self::Overlay => "overlay".to_string(),
            Self::Darken => "darken".to_string(),
            Self::Lighten => "lighten".to_string(),
            Self::ColorDodge => "color-dodge".to_string(),
            Self::ColorBurn => "color-burn".to_string(),
            Self::HardLight => "hard-light".to_string(),
            Self::SoftLight => "soft-light".to_string(),
            Self::Difference => "difference".to_string(),
            Self::Exclusion => "exclusion".to_string(),
            Self::Hue => "hue".to_string(),
            Self::Saturation => "saturation".to_string(),
            Self::Color => "color".to_string(),
            Self::Luminosity => "luminosity".to_string(),
        }
    }
}
impl std::str::FromStr for BlendValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "multiply" => Ok(Self::Multiply),
            "screen" => Ok(Self::Screen),
            "overlay" => Ok(Self::Overlay),
            "darken" => Ok(Self::Darken),
            "lighten" => Ok(Self::Lighten),
            "color-dodge" => Ok(Self::ColorDodge),
            "color-burn" => Ok(Self::ColorBurn),
            "hard-light" => Ok(Self::HardLight),
            "soft-light" => Ok(Self::SoftLight),
            "difference" => Ok(Self::Difference),
            "exclusion" => Ok(Self::Exclusion),
            "hue" => Ok(Self::Hue),
            "saturation" => Ok(Self::Saturation),
            "color" => Ok(Self::Color),
            "luminosity" => Ok(Self::Luminosity),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BlendValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BlendValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BlendValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BooleanOrSignal {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BooleanValue {
    #[educe(Default)]
    Variant0(Vec<BooleanValueVariant0Item>),
    Variant1(BooleanValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: BooleanValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BooleanValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BooleanValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BooleanValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BooleanValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BooleanValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BooleanValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: bool,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BooleanValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BooleanValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BooleanValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BooleanValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BooleanValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BooleanValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: bool,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BooleanValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum BooleanValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct BooleanValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CollectTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: CollectTransformType,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CollectTransformType {
    #[educe(Default)]
    #[serde(rename = "collect")]
    Collect,
}
impl ToString for CollectTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Collect => "collect".to_string(),
        }
    }
}
impl std::str::FromStr for CollectTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "collect" => Ok(Self::Collect),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CollectTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CollectTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ColorHcl {
    pub c: NumberValue,
    pub h: NumberValue,
    pub l: NumberValue,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ColorHsl {
    pub h: NumberValue,
    pub l: NumberValue,
    pub s: NumberValue,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ColorLab {
    pub a: NumberValue,
    pub b: NumberValue,
    pub l: NumberValue,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ColorRgb {
    pub b: NumberValue,
    pub g: NumberValue,
    pub r: NumberValue,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ColorValue {
    #[educe(Default)]
    Variant0(Vec<ColorValueVariant0Item>),
    Variant1(BaseColorValue),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ColorValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: BaseColorValue,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Compare {
    #[educe(Default)]
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        field: Option<CompareVariant0Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        field: Vec<CompareVariant1FieldItem>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        order: Vec<SortOrder>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CompareVariant0Field {
    #[educe(Default)]
    ScaleField(ScaleField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CompareVariant1FieldItem {
    #[educe(Default)]
    ScaleField(ScaleField),
    Expr(Expr),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ContourTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bandwidth: Option<ContourTransformBandwidth>,
    #[serde(rename = "cellSize", default, skip_serializing_if = "Option::is_none")]
    pub cell_size: Option<ContourTransformCellSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<ContourTransformCount>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nice: Option<ContourTransformNice>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub size: ContourTransformSize,
    #[serde(default = "defaults::contour_transform_smooth")]
    pub smooth: ContourTransformSmooth,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thresholds: Option<ContourTransformThresholds>,
    #[serde(rename = "type")]
    pub type_: ContourTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ContourTransformValues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<ContourTransformWeight>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x: Option<ContourTransformX>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y: Option<ContourTransformY>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformBandwidth {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformCellSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformCount {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformNice {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformSize {
    #[educe(Default)]
    Variant0(ContourTransformSizeVariant0, ContourTransformSizeVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformSmooth {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformThresholds {
    #[educe(Default)]
    Variant0(Vec<ContourTransformThresholdsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformThresholdsVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ContourTransformType {
    #[educe(Default)]
    #[serde(rename = "contour")]
    Contour,
}
impl ToString for ContourTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Contour => "contour".to_string(),
        }
    }
}
impl std::str::FromStr for ContourTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "contour" => Ok(Self::Contour),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ContourTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ContourTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformValues {
    #[educe(Default)]
    Variant0(Vec<ContourTransformValuesVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformValuesVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformWeight {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformX {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ContourTransformY {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CountpatternTransform {
    #[serde(rename = "as", default = "defaults::countpattern_transform_as")]
    pub as_: CountpatternTransformAs,
    #[serde(default = "defaults::countpattern_transform_case")]
    pub case: CountpatternTransformCase,
    pub field: CountpatternTransformField,
    #[serde(default = "defaults::countpattern_transform_pattern")]
    pub pattern: CountpatternTransformPattern,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stopwords: Option<CountpatternTransformStopwords>,
    #[serde(rename = "type")]
    pub type_: CountpatternTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CountpatternTransformAs {
    #[educe(Default)]
    Variant0(
        CountpatternTransformAsVariant0,
        CountpatternTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CountpatternTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CountpatternTransformCase {
    #[educe(Default)]
    Variant0(CountpatternTransformCaseVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CountpatternTransformCaseVariant0 {
    #[educe(Default)]
    #[serde(rename = "upper")]
    Upper,
    #[serde(rename = "lower")]
    Lower,
    #[serde(rename = "mixed")]
    Mixed,
}
impl ToString for CountpatternTransformCaseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Upper => "upper".to_string(),
            Self::Lower => "lower".to_string(),
            Self::Mixed => "mixed".to_string(),
        }
    }
}
impl std::str::FromStr for CountpatternTransformCaseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "upper" => Ok(Self::Upper),
            "lower" => Ok(Self::Lower),
            "mixed" => Ok(Self::Mixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CountpatternTransformCaseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CountpatternTransformCaseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CountpatternTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CountpatternTransformPattern {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CountpatternTransformStopwords {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CountpatternTransformType {
    #[educe(Default)]
    #[serde(rename = "countpattern")]
    Countpattern,
}
impl ToString for CountpatternTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Countpattern => "countpattern".to_string(),
        }
    }
}
impl std::str::FromStr for CountpatternTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "countpattern" => Ok(Self::Countpattern),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CountpatternTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CountpatternTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CrossTransform {
    #[serde(rename = "as", default = "defaults::cross_transform_as")]
    pub as_: CrossTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<ExprString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: CrossTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CrossTransformAs {
    #[educe(Default)]
    Variant0(CrossTransformAsVariant0, CrossTransformAsVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CrossTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CrossTransformType {
    #[educe(Default)]
    #[serde(rename = "cross")]
    Cross,
}
impl ToString for CrossTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Cross => "cross".to_string(),
        }
    }
}
impl std::str::FromStr for CrossTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "cross" => Ok(Self::Cross),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CrossTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CrossTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CrossfilterTransform {
    pub fields: CrossfilterTransformFields,
    pub query: CrossfilterTransformQuery,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: CrossfilterTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CrossfilterTransformFields {
    #[educe(Default)]
    Variant0(Vec<CrossfilterTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CrossfilterTransformFieldsVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum CrossfilterTransformQuery {
    #[educe(Default)]
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum CrossfilterTransformType {
    #[educe(Default)]
    #[serde(rename = "crossfilter")]
    Crossfilter,
}
impl ToString for CrossfilterTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Crossfilter => "crossfilter".to_string(),
        }
    }
}
impl std::str::FromStr for CrossfilterTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "crossfilter" => Ok(Self::Crossfilter),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CrossfilterTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CrossfilterTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Data {
    #[educe(Default)]
    Variant0 {
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
    },
    Variant1 {
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        source: DataVariant1Source,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
    },
    Variant2 {
        #[serde(rename = "async", default, skip_serializing_if = "Option::is_none")]
        async_: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<DataVariant2Format>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
        url: StringOrSignal,
    },
    Variant3 {
        #[serde(rename = "async", default, skip_serializing_if = "Option::is_none")]
        async_: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<DataVariant3Format>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
        values: DataVariant3Values,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant1Source {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<String>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant2Format {
    #[educe(Default)]
    Variant0(DataVariant2FormatVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DataVariant2FormatVariant0 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<DataVariant2FormatVariant0Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<DataVariant2FormatVariant0Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<DataVariant2FormatVariant0Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<DataVariant2FormatVariant0Subtype3>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_4: Option<DataVariant2FormatVariant0Subtype4>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DataVariant2FormatVariant0Subtype0 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype0Parse>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StringOrSignal>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype0Parse {
    #[educe(Default)]
    Variant0(DataVariant2FormatVariant0Subtype0ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant0 {
    #[educe(Default)]
    #[serde(rename = "auto")]
    Auto,
}
impl ToString for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra {
    #[educe(Default)]
    Variant0(DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    #[educe(Default)]
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ToString for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Serialize)]
pub struct DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub copy: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype1Parse>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub property: Option<StringOrSignal>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<DataVariant2FormatVariant0Subtype1Type>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype1Parse {
    #[educe(Default)]
    Variant0(DataVariant2FormatVariant0Subtype1ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant0 {
    #[educe(Default)]
    #[serde(rename = "auto")]
    Auto,
}
impl ToString for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra {
    #[educe(Default)]
    Variant0(DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    #[educe(Default)]
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ToString for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Serialize)]
pub struct DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype1Type {
    #[educe(Default)]
    #[serde(rename = "json")]
    Json,
}
impl ToString for DataVariant2FormatVariant0Subtype1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype2 {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype2Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant2FormatVariant0Subtype2Type,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype2Parse {
    #[educe(Default)]
    Variant0(DataVariant2FormatVariant0Subtype2ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant0 {
    #[educe(Default)]
    #[serde(rename = "auto")]
    Auto,
}
impl ToString for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra {
    #[educe(Default)]
    Variant0(DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    #[educe(Default)]
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ToString for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Serialize)]
pub struct DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype2Type {
    #[educe(Default)]
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
}
impl ToString for DataVariant2FormatVariant0Subtype2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Csv => "csv".to_string(),
            Self::Tsv => "tsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "csv" => Ok(Self::Csv),
            "tsv" => Ok(Self::Tsv),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype3 {
    pub delimiter: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype3Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant2FormatVariant0Subtype3Type,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype3Parse {
    #[educe(Default)]
    Variant0(DataVariant2FormatVariant0Subtype3ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant0 {
    #[educe(Default)]
    #[serde(rename = "auto")]
    Auto,
}
impl ToString for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra {
    #[educe(Default)]
    Variant0(DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    #[educe(Default)]
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ToString for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Serialize)]
pub struct DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype3Type {
    #[educe(Default)]
    #[serde(rename = "dsv")]
    Dsv,
}
impl ToString for DataVariant2FormatVariant0Subtype3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Dsv => "dsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dsv" => Ok(Self::Dsv),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype4 {
    #[educe(Default)]
    Variant0 {
        feature: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant2FormatVariant0Subtype4Variant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        filter: Option<DataVariant2FormatVariant0Subtype4Variant1Filter>,
        mesh: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant2FormatVariant0Subtype4Variant1Type,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype4Variant0Type {
    #[educe(Default)]
    #[serde(rename = "topojson")]
    Topojson,
}
impl ToString for DataVariant2FormatVariant0Subtype4Variant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype4Variant1Filter {
    #[educe(Default)]
    #[serde(rename = "interior")]
    Interior,
    #[serde(rename = "exterior")]
    Exterior,
}
impl ToString for DataVariant2FormatVariant0Subtype4Variant1Filter {
    fn to_string(&self) -> String {
        match *self {
            Self::Interior => "interior".to_string(),
            Self::Exterior => "exterior".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "interior" => Ok(Self::Interior),
            "exterior" => Ok(Self::Exterior),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant2FormatVariant0Subtype4Variant1Type {
    #[educe(Default)]
    #[serde(rename = "topojson")]
    Topojson,
}
impl ToString for DataVariant2FormatVariant0Subtype4Variant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant3Format {
    #[educe(Default)]
    Variant0(DataVariant3FormatVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DataVariant3FormatVariant0 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<DataVariant3FormatVariant0Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<DataVariant3FormatVariant0Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<DataVariant3FormatVariant0Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<DataVariant3FormatVariant0Subtype3>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_4: Option<DataVariant3FormatVariant0Subtype4>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DataVariant3FormatVariant0Subtype0 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype0Parse>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StringOrSignal>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype0Parse {
    #[educe(Default)]
    Variant0(DataVariant3FormatVariant0Subtype0ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant0 {
    #[educe(Default)]
    #[serde(rename = "auto")]
    Auto,
}
impl ToString for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra {
    #[educe(Default)]
    Variant0(DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    #[educe(Default)]
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ToString for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Serialize)]
pub struct DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub copy: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype1Parse>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub property: Option<StringOrSignal>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<DataVariant3FormatVariant0Subtype1Type>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype1Parse {
    #[educe(Default)]
    Variant0(DataVariant3FormatVariant0Subtype1ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant0 {
    #[educe(Default)]
    #[serde(rename = "auto")]
    Auto,
}
impl ToString for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra {
    #[educe(Default)]
    Variant0(DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    #[educe(Default)]
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ToString for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Serialize)]
pub struct DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype1Type {
    #[educe(Default)]
    #[serde(rename = "json")]
    Json,
}
impl ToString for DataVariant3FormatVariant0Subtype1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype2 {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype2Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant3FormatVariant0Subtype2Type,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype2Parse {
    #[educe(Default)]
    Variant0(DataVariant3FormatVariant0Subtype2ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant0 {
    #[educe(Default)]
    #[serde(rename = "auto")]
    Auto,
}
impl ToString for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra {
    #[educe(Default)]
    Variant0(DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    #[educe(Default)]
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ToString for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Serialize)]
pub struct DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype2Type {
    #[educe(Default)]
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
}
impl ToString for DataVariant3FormatVariant0Subtype2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Csv => "csv".to_string(),
            Self::Tsv => "tsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "csv" => Ok(Self::Csv),
            "tsv" => Ok(Self::Tsv),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype3 {
    pub delimiter: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype3Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant3FormatVariant0Subtype3Type,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype3Parse {
    #[educe(Default)]
    Variant0(DataVariant3FormatVariant0Subtype3ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant0 {
    #[educe(Default)]
    #[serde(rename = "auto")]
    Auto,
}
impl ToString for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra {
    #[educe(Default)]
    Variant0(DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    #[educe(Default)]
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ToString for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Serialize)]
pub struct DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype3Type {
    #[educe(Default)]
    #[serde(rename = "dsv")]
    Dsv,
}
impl ToString for DataVariant3FormatVariant0Subtype3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Dsv => "dsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dsv" => Ok(Self::Dsv),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype4 {
    #[educe(Default)]
    Variant0 {
        feature: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant3FormatVariant0Subtype4Variant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        filter: Option<DataVariant3FormatVariant0Subtype4Variant1Filter>,
        mesh: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant3FormatVariant0Subtype4Variant1Type,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype4Variant0Type {
    #[educe(Default)]
    #[serde(rename = "topojson")]
    Topojson,
}
impl ToString for DataVariant3FormatVariant0Subtype4Variant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype4Variant1Filter {
    #[educe(Default)]
    #[serde(rename = "interior")]
    Interior,
    #[serde(rename = "exterior")]
    Exterior,
}
impl ToString for DataVariant3FormatVariant0Subtype4Variant1Filter {
    fn to_string(&self) -> String {
        match *self {
            Self::Interior => "interior".to_string(),
            Self::Exterior => "exterior".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "interior" => Ok(Self::Interior),
            "exterior" => Ok(Self::Exterior),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DataVariant3FormatVariant0Subtype4Variant1Type {
    #[educe(Default)]
    #[serde(rename = "topojson")]
    Topojson,
}
impl ToString for DataVariant3FormatVariant0Subtype4Variant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DataVariant3Values {
    #[educe(Default)]
    Variant0(serde_json::Value),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DensityTransform {
    #[serde(rename = "as", default = "defaults::density_transform_as")]
    pub as_: DensityTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribution: Option<DensityTransformDistribution>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<DensityTransformExtent>,
    #[serde(default = "defaults::density_transform_maxsteps")]
    pub maxsteps: DensityTransformMaxsteps,
    #[serde(default = "defaults::density_transform_method")]
    pub method: DensityTransformMethod,
    #[serde(default = "defaults::density_transform_minsteps")]
    pub minsteps: DensityTransformMinsteps,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<DensityTransformSteps>,
    #[serde(rename = "type")]
    pub type_: DensityTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformAs {
    #[educe(Default)]
    Variant0(Vec<DensityTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum DensityTransformDistribution {
    #[educe(Default)]
    Variant0 {
        function: DensityTransformDistributionVariant0Function,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mean: Option<DensityTransformDistributionVariant0Mean>,
        #[serde(default = "defaults::density_transform_distribution_variant0_stdev")]
        stdev: DensityTransformDistributionVariant0Stdev,
    },
    Variant1 {
        function: DensityTransformDistributionVariant1Function,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mean: Option<DensityTransformDistributionVariant1Mean>,
        #[serde(default = "defaults::density_transform_distribution_variant1_stdev")]
        stdev: DensityTransformDistributionVariant1Stdev,
    },
    Variant2 {
        function: DensityTransformDistributionVariant2Function,
        #[serde(default = "defaults::density_transform_distribution_variant2_max")]
        max: DensityTransformDistributionVariant2Max,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        min: Option<DensityTransformDistributionVariant2Min>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bandwidth: Option<DensityTransformDistributionVariant3Bandwidth>,
        field: DensityTransformDistributionVariant3Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        from: Option<String>,
        function: DensityTransformDistributionVariant3Function,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        distributions: Option<DensityTransformDistributionVariant4Distributions>,
        function: DensityTransformDistributionVariant4Function,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        weights: Option<DensityTransformDistributionVariant4Weights>,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DensityTransformDistributionVariant0Function {
    #[educe(Default)]
    #[serde(rename = "normal")]
    Normal,
}
impl ToString for DensityTransformDistributionVariant0Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Normal => "normal".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant0Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "normal" => Ok(Self::Normal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant0Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant0Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant0Mean {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant0Stdev {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DensityTransformDistributionVariant1Function {
    #[educe(Default)]
    #[serde(rename = "lognormal")]
    Lognormal,
}
impl ToString for DensityTransformDistributionVariant1Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Lognormal => "lognormal".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant1Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "lognormal" => Ok(Self::Lognormal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant1Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant1Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant1Mean {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant1Stdev {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DensityTransformDistributionVariant2Function {
    #[educe(Default)]
    #[serde(rename = "uniform")]
    Uniform,
}
impl ToString for DensityTransformDistributionVariant2Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Uniform => "uniform".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant2Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "uniform" => Ok(Self::Uniform),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant2Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant2Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant2Max {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant2Min {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant3Bandwidth {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant3Field {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DensityTransformDistributionVariant3Function {
    #[educe(Default)]
    #[serde(rename = "kde")]
    Kde,
}
impl ToString for DensityTransformDistributionVariant3Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Kde => "kde".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant3Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "kde" => Ok(Self::Kde),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant3Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant3Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant4Distributions {
    #[educe(Default)]
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DensityTransformDistributionVariant4Function {
    #[educe(Default)]
    #[serde(rename = "mixture")]
    Mixture,
}
impl ToString for DensityTransformDistributionVariant4Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Mixture => "mixture".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant4Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "mixture" => Ok(Self::Mixture),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant4Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant4Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant4Weights {
    #[educe(Default)]
    Variant0(Vec<DensityTransformDistributionVariant4WeightsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant4WeightsVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformExtent {
    #[educe(Default)]
    Variant0(
        DensityTransformExtentVariant0,
        DensityTransformExtentVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformExtentVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformMaxsteps {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformMethod {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformMinsteps {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DensityTransformSteps {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DensityTransformType {
    #[educe(Default)]
    #[serde(rename = "density")]
    Density,
}
impl ToString for DensityTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Density => "density".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "density" => Ok(Self::Density),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DirectionValue {
    #[educe(Default)]
    Variant0(Vec<DirectionValueVariant0Item>),
    Variant1(DirectionValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: DirectionValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: DirectionValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<DirectionValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<DirectionValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<DirectionValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<DirectionValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DirectionValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
}
impl ToString for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Horizontal => "horizontal".to_string(),
            Self::Vertical => "vertical".to_string(),
        }
    }
}
impl std::str::FromStr for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: DirectionValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<DirectionValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<DirectionValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<DirectionValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<DirectionValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DirectionValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: DirectionValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: DirectionValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DirectionValueVariant1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
}
impl ToString for DirectionValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Horizontal => "horizontal".to_string(),
            Self::Vertical => "vertical".to_string(),
        }
    }
}
impl std::str::FromStr for DirectionValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DirectionValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DirectionValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DirectionValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct DirectionValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DotbinTransform {
    #[serde(rename = "as", default = "defaults::dotbin_transform_as")]
    pub as_: DotbinTransformAs,
    pub field: DotbinTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<DotbinTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub smooth: Option<DotbinTransformSmooth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<DotbinTransformStep>,
    #[serde(rename = "type")]
    pub type_: DotbinTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DotbinTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DotbinTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DotbinTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<DotbinTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DotbinTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DotbinTransformSmooth {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum DotbinTransformStep {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum DotbinTransformType {
    #[educe(Default)]
    #[serde(rename = "dotbin")]
    Dotbin,
}
impl ToString for DotbinTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Dotbin => "dotbin".to_string(),
        }
    }
}
impl std::str::FromStr for DotbinTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dotbin" => Ok(Self::Dotbin),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DotbinTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DotbinTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Element(pub String);
impl std::ops::Deref for Element {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Encode {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct EncodeEntry {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub align: Option<AlignValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<BooleanValue>,
    #[serde(rename = "ariaRole", default, skip_serializing_if = "Option::is_none")]
    pub aria_role: Option<StringValue>,
    #[serde(
        rename = "ariaRoleDescription",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub aria_role_description: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aspect: Option<BooleanValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub baseline: Option<BaselineValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blend: Option<BlendValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clip: Option<BooleanValue>,
    #[serde(
        rename = "cornerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusBottomLeft",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_bottom_left: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusBottomRight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_bottom_right: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusTopLeft",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_top_left: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusTopRight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_top_right: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cursor: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defined: Option<BooleanValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dir: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dx: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dy: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ellipsis: Option<StringValue>,
    #[serde(rename = "endAngle", default, skip_serializing_if = "Option::is_none")]
    pub end_angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fill: Option<ColorValue>,
    #[serde(
        rename = "fillOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub fill_opacity: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub font: Option<StringValue>,
    #[serde(rename = "fontSize", default, skip_serializing_if = "Option::is_none")]
    pub font_size: Option<NumberValue>,
    #[serde(rename = "fontStyle", default, skip_serializing_if = "Option::is_none")]
    pub font_style: Option<StringValue>,
    #[serde(
        rename = "fontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub font_weight: Option<FontWeightValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<NumberValue>,
    #[serde(
        rename = "innerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub inner_radius: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpolate: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limit: Option<NumberValue>,
    #[serde(rename = "lineBreak", default, skip_serializing_if = "Option::is_none")]
    pub line_break: Option<StringValue>,
    #[serde(
        rename = "lineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub line_height: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opacity: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub orient: Option<DirectionValue>,
    #[serde(
        rename = "outerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub outer_radius: Option<NumberValue>,
    #[serde(rename = "padAngle", default, skip_serializing_if = "Option::is_none")]
    pub pad_angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub radius: Option<NumberValue>,
    #[serde(rename = "scaleX", default, skip_serializing_if = "Option::is_none")]
    pub scale_x: Option<NumberValue>,
    #[serde(rename = "scaleY", default, skip_serializing_if = "Option::is_none")]
    pub scale_y: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shape: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub smooth: Option<BooleanValue>,
    #[serde(
        rename = "startAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub start_angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stroke: Option<ColorValue>,
    #[serde(rename = "strokeCap", default, skip_serializing_if = "Option::is_none")]
    pub stroke_cap: Option<StrokeCapValue>,
    #[serde(
        rename = "strokeDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_dash: Option<ArrayValue>,
    #[serde(
        rename = "strokeDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_dash_offset: Option<NumberValue>,
    #[serde(
        rename = "strokeForeground",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_foreground: Option<BooleanValue>,
    #[serde(
        rename = "strokeJoin",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_join: Option<StrokeJoinValue>,
    #[serde(
        rename = "strokeMiterLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_miter_limit: Option<NumberValue>,
    #[serde(
        rename = "strokeOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_offset: Option<NumberValue>,
    #[serde(
        rename = "strokeOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_opacity: Option<NumberValue>,
    #[serde(
        rename = "strokeWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_width: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tension: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<TextValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub theta: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tooltip: Option<AnyValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x2: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub xc: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y2: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub yc: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zindex: Option<NumberValue>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Everything {
    #[serde(flatten)]
    pub subtype_0: Scope,
    #[serde(flatten)]
    pub subtype_1: EverythingSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct EverythingSubtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autosize: Option<Autosize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub background: Option<Background>,
    #[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub config: std::collections::HashMap<String, serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<Padding>,
    #[serde(rename = "$schema", default, skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<NumberOrSignal>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Expr {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<String>,
    pub expr: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ExprString(pub String);
impl std::ops::Deref for ExprString {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ExtentTransform {
    pub field: ExtentTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ExtentTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ExtentTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ExtentTransformType {
    #[educe(Default)]
    #[serde(rename = "extent")]
    Extent,
}
impl ToString for ExtentTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Extent => "extent".to_string(),
        }
    }
}
impl std::str::FromStr for ExtentTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "extent" => Ok(Self::Extent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ExtentTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ExtentTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Facet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    pub facet: FacetFacet,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum FacetFacet {
    #[educe(Default)]
    Variant0 {
        data: String,
        field: String,
        name: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aggregate: Option<FacetFacetVariant1Aggregate>,
        data: String,
        groupby: FacetFacetVariant1Groupby,
        name: String,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FacetFacetVariant1Aggregate {
    #[serde(rename = "as", default, skip_serializing_if = "Vec::is_empty")]
    pub as_: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cross: Option<bool>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub fields: Vec<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub ops: Vec<String>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FacetFacetVariant1Groupby {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<String>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Field {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2 {
        datum: Box<Field>,
    },
    Variant3 {
        group: Box<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        level: Option<f64>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        level: Option<f64>,
        parent: Box<Field>,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FilterTransform {
    pub expr: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FilterTransformType,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum FilterTransformType {
    #[educe(Default)]
    #[serde(rename = "filter")]
    Filter,
}
impl ToString for FilterTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Filter => "filter".to_string(),
        }
    }
}
impl std::str::FromStr for FilterTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "filter" => Ok(Self::Filter),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for FilterTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FilterTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FlattenTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<FlattenTransformAs>,
    pub fields: FlattenTransformFields,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<FlattenTransformIndex>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FlattenTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FlattenTransformAs {
    #[educe(Default)]
    Variant0(Vec<FlattenTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FlattenTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FlattenTransformFields {
    #[educe(Default)]
    Variant0(Vec<FlattenTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FlattenTransformFieldsVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FlattenTransformIndex {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum FlattenTransformType {
    #[educe(Default)]
    #[serde(rename = "flatten")]
    Flatten,
}
impl ToString for FlattenTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Flatten => "flatten".to_string(),
        }
    }
}
impl std::str::FromStr for FlattenTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "flatten" => Ok(Self::Flatten),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for FlattenTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FlattenTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FoldTransform {
    #[serde(rename = "as", default = "defaults::fold_transform_as")]
    pub as_: FoldTransformAs,
    pub fields: FoldTransformFields,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FoldTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FoldTransformAs {
    #[educe(Default)]
    Variant0(FoldTransformAsVariant0, FoldTransformAsVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FoldTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FoldTransformFields {
    #[educe(Default)]
    Variant0(Vec<FoldTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FoldTransformFieldsVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum FoldTransformType {
    #[educe(Default)]
    #[serde(rename = "fold")]
    Fold,
}
impl ToString for FoldTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Fold => "fold".to_string(),
        }
    }
}
impl std::str::FromStr for FoldTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "fold" => Ok(Self::Fold),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for FoldTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FoldTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FontWeightValue {
    #[educe(Default)]
    Variant0(Vec<FontWeightValueVariant0Item>),
    Variant1(FontWeightValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: FontWeightValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: FontWeightValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<FontWeightValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<FontWeightValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<FontWeightValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<FontWeightValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FontWeightValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: MyEnum,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: FontWeightValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<FontWeightValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<FontWeightValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<FontWeightValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<FontWeightValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FontWeightValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: MyEnum,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: FontWeightValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FontWeightValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct FontWeightValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ForceTransform {
    #[serde(default = "defaults::force_transform_alpha")]
    pub alpha: ForceTransformAlpha,
    #[serde(rename = "alphaMin", default = "defaults::force_transform_alpha_min")]
    pub alpha_min: ForceTransformAlphaMin,
    #[serde(
        rename = "alphaTarget",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub alpha_target: Option<ForceTransformAlphaTarget>,
    #[serde(rename = "as", default = "defaults::force_transform_as")]
    pub as_: ForceTransformAs,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub forces: Vec<ForceTransformForcesItem>,
    #[serde(default = "defaults::force_transform_iterations")]
    pub iterations: ForceTransformIterations,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restart: Option<ForceTransformRestart>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "static", default, skip_serializing_if = "Option::is_none")]
    pub static_: Option<ForceTransformStatic>,
    #[serde(rename = "type")]
    pub type_: ForceTransformType,
    #[serde(
        rename = "velocityDecay",
        default = "defaults::force_transform_velocity_decay"
    )]
    pub velocity_decay: ForceTransformVelocityDecay,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformAlpha {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformAlphaMin {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformAlphaTarget {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformAs {
    #[educe(Default)]
    Variant0(Vec<ForceTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ForceTransformForcesItem {
    #[educe(Default)]
    Variant0 {
        force: ForceTransformForcesItemVariant0Force,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        x: Option<ForceTransformForcesItemVariant0X>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        y: Option<ForceTransformForcesItemVariant0Y>,
    },
    Variant1 {
        force: ForceTransformForcesItemVariant1Force,
        #[serde(default = "defaults::force_transform_forces_item_variant1_iterations")]
        iterations: ForceTransformForcesItemVariant1Iterations,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        radius: Option<ForceTransformForcesItemVariant1Radius>,
        #[serde(default = "defaults::force_transform_forces_item_variant1_strength")]
        strength: ForceTransformForcesItemVariant1Strength,
    },
    Variant2 {
        #[serde(
            rename = "distanceMax",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        distance_max: Option<ForceTransformForcesItemVariant2DistanceMax>,
        #[serde(
            rename = "distanceMin",
            default = "defaults::force_transform_forces_item_variant2_distance_min"
        )]
        distance_min: ForceTransformForcesItemVariant2DistanceMin,
        force: ForceTransformForcesItemVariant2Force,
        #[serde(default = "defaults::force_transform_forces_item_variant2_strength")]
        strength: ForceTransformForcesItemVariant2Strength,
        #[serde(default = "defaults::force_transform_forces_item_variant2_theta")]
        theta: ForceTransformForcesItemVariant2Theta,
    },
    Variant3 {
        #[serde(default = "defaults::force_transform_forces_item_variant3_distance")]
        distance: ForceTransformForcesItemVariant3Distance,
        force: ForceTransformForcesItemVariant3Force,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        id: Option<ForceTransformForcesItemVariant3Id>,
        #[serde(default = "defaults::force_transform_forces_item_variant3_iterations")]
        iterations: ForceTransformForcesItemVariant3Iterations,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        links: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        strength: Option<ForceTransformForcesItemVariant3Strength>,
    },
    Variant4 {
        force: ForceTransformForcesItemVariant4Force,
        #[serde(default = "defaults::force_transform_forces_item_variant4_strength")]
        strength: ForceTransformForcesItemVariant4Strength,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        x: Option<ForceTransformForcesItemVariant4X>,
    },
    Variant5 {
        force: ForceTransformForcesItemVariant5Force,
        #[serde(default = "defaults::force_transform_forces_item_variant5_strength")]
        strength: ForceTransformForcesItemVariant5Strength,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        y: Option<ForceTransformForcesItemVariant5Y>,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ForceTransformForcesItemVariant0Force {
    #[educe(Default)]
    #[serde(rename = "center")]
    Center,
}
impl ToString for ForceTransformForcesItemVariant0Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant0Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant0Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant0Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant0X {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant0Y {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ForceTransformForcesItemVariant1Force {
    #[educe(Default)]
    #[serde(rename = "collide")]
    Collide,
}
impl ToString for ForceTransformForcesItemVariant1Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Collide => "collide".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant1Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "collide" => Ok(Self::Collide),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant1Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant1Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant1Iterations {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant1Radius {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant1Strength {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant2DistanceMax {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant2DistanceMin {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ForceTransformForcesItemVariant2Force {
    #[educe(Default)]
    #[serde(rename = "nbody")]
    Nbody,
}
impl ToString for ForceTransformForcesItemVariant2Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Nbody => "nbody".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant2Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "nbody" => Ok(Self::Nbody),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant2Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant2Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant2Strength {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant2Theta {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant3Distance {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ForceTransformForcesItemVariant3Force {
    #[educe(Default)]
    #[serde(rename = "link")]
    Link,
}
impl ToString for ForceTransformForcesItemVariant3Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Link => "link".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant3Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "link" => Ok(Self::Link),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant3Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant3Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant3Id {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant3Iterations {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant3Strength {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ForceTransformForcesItemVariant4Force {
    #[educe(Default)]
    #[serde(rename = "x")]
    X,
}
impl ToString for ForceTransformForcesItemVariant4Force {
    fn to_string(&self) -> String {
        match *self {
            Self::X => "x".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant4Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "x" => Ok(Self::X),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant4Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant4Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant4Strength {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant4X {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ForceTransformForcesItemVariant5Force {
    #[educe(Default)]
    #[serde(rename = "y")]
    Y,
}
impl ToString for ForceTransformForcesItemVariant5Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Y => "y".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant5Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "y" => Ok(Self::Y),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant5Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant5Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant5Strength {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant5Y {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformIterations {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformRestart {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformStatic {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ForceTransformType {
    #[educe(Default)]
    #[serde(rename = "force")]
    Force,
}
impl ToString for ForceTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Force => "force".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "force" => Ok(Self::Force),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ForceTransformVelocityDecay {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FormulaTransform {
    #[serde(rename = "as")]
    pub as_: FormulaTransformAs,
    pub expr: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initonly: Option<FormulaTransformInitonly>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FormulaTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FormulaTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum FormulaTransformInitonly {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum FormulaTransformType {
    #[educe(Default)]
    #[serde(rename = "formula")]
    Formula,
}
impl ToString for FormulaTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Formula => "formula".to_string(),
        }
    }
}
impl std::str::FromStr for FormulaTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "formula" => Ok(Self::Formula),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for FormulaTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FormulaTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct From {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeojsonTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<GeojsonTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub geojson: Option<GeojsonTransformGeojson>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeojsonTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeojsonTransformFields {
    #[educe(Default)]
    Variant0(
        GeojsonTransformFieldsVariant0,
        GeojsonTransformFieldsVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeojsonTransformFieldsVariant0 {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeojsonTransformGeojson {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum GeojsonTransformType {
    #[educe(Default)]
    #[serde(rename = "geojson")]
    Geojson,
}
impl ToString for GeojsonTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geojson => "geojson".to_string(),
        }
    }
}
impl std::str::FromStr for GeojsonTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "geojson" => Ok(Self::Geojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GeojsonTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeojsonTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeopathTransform {
    #[serde(rename = "as", default = "defaults::geopath_transform_as")]
    pub as_: GeopathTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<GeopathTransformField>,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub point_radius: Option<GeopathTransformPointRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projection: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeopathTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeopathTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeopathTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeopathTransformPointRadius {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum GeopathTransformType {
    #[educe(Default)]
    #[serde(rename = "geopath")]
    Geopath,
}
impl ToString for GeopathTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geopath => "geopath".to_string(),
        }
    }
}
impl std::str::FromStr for GeopathTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "geopath" => Ok(Self::Geopath),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GeopathTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeopathTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeopointTransform {
    #[serde(rename = "as", default = "defaults::geopoint_transform_as")]
    pub as_: GeopointTransformAs,
    pub fields: GeopointTransformFields,
    pub projection: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeopointTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeopointTransformAs {
    #[educe(Default)]
    Variant0(GeopointTransformAsVariant0, GeopointTransformAsVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeopointTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeopointTransformFields {
    #[educe(Default)]
    Variant0(
        GeopointTransformFieldsVariant0,
        GeopointTransformFieldsVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeopointTransformFieldsVariant0 {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum GeopointTransformType {
    #[educe(Default)]
    #[serde(rename = "geopoint")]
    Geopoint,
}
impl ToString for GeopointTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geopoint => "geopoint".to_string(),
        }
    }
}
impl std::str::FromStr for GeopointTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "geopoint" => Ok(Self::Geopoint),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GeopointTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeopointTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeoshapeTransform {
    #[serde(rename = "as", default = "defaults::geoshape_transform_as")]
    pub as_: GeoshapeTransformAs,
    #[serde(default = "defaults::geoshape_transform_field")]
    pub field: GeoshapeTransformField,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub point_radius: Option<GeoshapeTransformPointRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projection: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeoshapeTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeoshapeTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeoshapeTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GeoshapeTransformPointRadius {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum GeoshapeTransformType {
    #[educe(Default)]
    #[serde(rename = "geoshape")]
    Geoshape,
}
impl ToString for GeoshapeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geoshape => "geoshape".to_string(),
        }
    }
}
impl std::str::FromStr for GeoshapeTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "geoshape" => Ok(Self::Geoshape),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GeoshapeTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeoshapeTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct GradientStops(pub Vec<GradientStopsItem>);
impl std::ops::Deref for GradientStops {
    type Target = Vec<GradientStopsItem>;
    fn deref(&self) -> &Vec<GradientStopsItem> {
        &self.0
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GradientStopsItem {
    pub color: String,
    pub offset: f64,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GraticuleTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<GraticuleTransformExtent>,
    #[serde(
        rename = "extentMajor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub extent_major: Option<GraticuleTransformExtentMajor>,
    #[serde(
        rename = "extentMinor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub extent_minor: Option<GraticuleTransformExtentMinor>,
    #[serde(default = "defaults::graticule_transform_precision")]
    pub precision: GraticuleTransformPrecision,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<GraticuleTransformStep>,
    #[serde(
        rename = "stepMajor",
        default = "defaults::graticule_transform_step_major"
    )]
    pub step_major: GraticuleTransformStepMajor,
    #[serde(
        rename = "stepMinor",
        default = "defaults::graticule_transform_step_minor"
    )]
    pub step_minor: GraticuleTransformStepMinor,
    #[serde(rename = "type")]
    pub type_: GraticuleTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformExtent {
    #[educe(Default)]
    Variant0(serde_json::Value, serde_json::Value),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformExtentMajor {
    #[educe(Default)]
    Variant0(serde_json::Value, serde_json::Value),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformExtentMinor {
    #[educe(Default)]
    Variant0(serde_json::Value, serde_json::Value),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformPrecision {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformStep {
    #[educe(Default)]
    Variant0(
        GraticuleTransformStepVariant0,
        GraticuleTransformStepVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformStepMajor {
    #[educe(Default)]
    Variant0(
        GraticuleTransformStepMajorVariant0,
        GraticuleTransformStepMajorVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformStepMajorVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformStepMinor {
    #[educe(Default)]
    Variant0(
        GraticuleTransformStepMinorVariant0,
        GraticuleTransformStepMinorVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformStepMinorVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum GraticuleTransformStepVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum GraticuleTransformType {
    #[educe(Default)]
    #[serde(rename = "graticule")]
    Graticule,
}
impl ToString for GraticuleTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Graticule => "graticule".to_string(),
        }
    }
}
impl std::str::FromStr for GraticuleTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "graticule" => Ok(Self::Graticule),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GraticuleTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GraticuleTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GuideEncode {
    #[serde(default)]
    pub interactive: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct HeatmapTransform {
    #[serde(rename = "as", default = "defaults::heatmap_transform_as")]
    pub as_: HeatmapTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<HeatmapTransformColor>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<HeatmapTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opacity: Option<HeatmapTransformOpacity>,
    #[serde(default = "defaults::heatmap_transform_resolve")]
    pub resolve: HeatmapTransformResolve,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: HeatmapTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum HeatmapTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum HeatmapTransformColor {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum HeatmapTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum HeatmapTransformOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum HeatmapTransformResolve {
    #[educe(Default)]
    Variant0(HeatmapTransformResolveVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum HeatmapTransformResolveVariant0 {
    #[educe(Default)]
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl ToString for HeatmapTransformResolveVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Shared => "shared".to_string(),
            Self::Independent => "independent".to_string(),
        }
    }
}
impl std::str::FromStr for HeatmapTransformResolveVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for HeatmapTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for HeatmapTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum HeatmapTransformType {
    #[educe(Default)]
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for HeatmapTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for HeatmapTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for HeatmapTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for HeatmapTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentifierTransform {
    #[serde(rename = "as")]
    pub as_: IdentifierTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: IdentifierTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IdentifierTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IdentifierTransformType {
    #[educe(Default)]
    #[serde(rename = "identifier")]
    Identifier,
}
impl ToString for IdentifierTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Identifier => "identifier".to_string(),
        }
    }
}
impl std::str::FromStr for IdentifierTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "identifier" => Ok(Self::Identifier),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IdentifierTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IdentifierTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ImputeTransform {
    pub field: ImputeTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<ImputeTransformGroupby>,
    pub key: ImputeTransformKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyvals: Option<ImputeTransformKeyvals>,
    #[serde(default = "defaults::impute_transform_method")]
    pub method: ImputeTransformMethod,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ImputeTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ImputeTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ImputeTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<ImputeTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ImputeTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ImputeTransformKey {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ImputeTransformKeyvals {
    #[educe(Default)]
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ImputeTransformMethod {
    #[educe(Default)]
    Variant0(ImputeTransformMethodVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ImputeTransformMethodVariant0 {
    #[educe(Default)]
    #[serde(rename = "value")]
    Value,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "min")]
    Min,
}
impl ToString for ImputeTransformMethodVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Value => "value".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Median => "median".to_string(),
            Self::Max => "max".to_string(),
            Self::Min => "min".to_string(),
        }
    }
}
impl std::str::FromStr for ImputeTransformMethodVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "value" => Ok(Self::Value),
            "mean" => Ok(Self::Mean),
            "median" => Ok(Self::Median),
            "max" => Ok(Self::Max),
            "min" => Ok(Self::Min),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ImputeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ImputeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ImputeTransformType {
    #[educe(Default)]
    #[serde(rename = "impute")]
    Impute,
}
impl ToString for ImputeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Impute => "impute".to_string(),
        }
    }
}
impl std::str::FromStr for ImputeTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "impute" => Ok(Self::Impute),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ImputeTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ImputeTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IsocontourTransform {
    #[serde(rename = "as", default = "defaults::isocontour_transform_as")]
    pub as_: IsocontourTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<IsocontourTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub levels: Option<IsocontourTransformLevels>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nice: Option<IsocontourTransformNice>,
    #[serde(default = "defaults::isocontour_transform_resolve")]
    pub resolve: IsocontourTransformResolve,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<IsocontourTransformScale>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::isocontour_transform_smooth")]
    pub smooth: IsocontourTransformSmooth,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thresholds: Option<IsocontourTransformThresholds>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<IsocontourTransformTranslate>,
    #[serde(rename = "type")]
    pub type_: IsocontourTransformType,
    #[serde(default = "defaults::isocontour_transform_zero")]
    pub zero: IsocontourTransformZero,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformLevels {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformNice {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformResolve {
    #[educe(Default)]
    Variant0(IsocontourTransformResolveVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IsocontourTransformResolveVariant0 {
    #[educe(Default)]
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl ToString for IsocontourTransformResolveVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Shared => "shared".to_string(),
            Self::Independent => "independent".to_string(),
        }
    }
}
impl std::str::FromStr for IsocontourTransformResolveVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IsocontourTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IsocontourTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformScale {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformSmooth {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformThresholds {
    #[educe(Default)]
    Variant0(Vec<IsocontourTransformThresholdsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformThresholdsVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformTranslate {
    #[educe(Default)]
    Variant0(Vec<IsocontourTransformTranslateVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformTranslateVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum IsocontourTransformType {
    #[educe(Default)]
    #[serde(rename = "isocontour")]
    Isocontour,
}
impl ToString for IsocontourTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Isocontour => "isocontour".to_string(),
        }
    }
}
impl std::str::FromStr for IsocontourTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "isocontour" => Ok(Self::Isocontour),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IsocontourTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IsocontourTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum IsocontourTransformZero {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct JoinaggregateTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<JoinaggregateTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<JoinaggregateTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<JoinaggregateTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<JoinaggregateTransformKey>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ops: Option<JoinaggregateTransformOps>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: JoinaggregateTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum JoinaggregateTransformAs {
    #[educe(Default)]
    Variant0(Vec<JoinaggregateTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum JoinaggregateTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum JoinaggregateTransformFields {
    #[educe(Default)]
    Variant0(Vec<JoinaggregateTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum JoinaggregateTransformFieldsVariant0Item {
    #[educe(Default)]
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum JoinaggregateTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<JoinaggregateTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum JoinaggregateTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum JoinaggregateTransformKey {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum JoinaggregateTransformOps {
    #[educe(Default)]
    Variant0(Vec<JoinaggregateTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum JoinaggregateTransformOpsVariant0Item {
    #[educe(Default)]
    Variant0(JoinaggregateTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum JoinaggregateTransformOpsVariant0ItemVariant0 {
    #[educe(Default)]
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl ToString for JoinaggregateTransformOpsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum JoinaggregateTransformType {
    #[educe(Default)]
    #[serde(rename = "joinaggregate")]
    Joinaggregate,
}
impl ToString for JoinaggregateTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Joinaggregate => "joinaggregate".to_string(),
        }
    }
}
impl std::str::FromStr for JoinaggregateTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "joinaggregate" => Ok(Self::Joinaggregate),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for JoinaggregateTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for JoinaggregateTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Kde2dTransform {
    #[serde(rename = "as", default = "defaults::kde2d_transform_as")]
    pub as_: Kde2dTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bandwidth: Option<Kde2dTransformBandwidth>,
    #[serde(rename = "cellSize", default, skip_serializing_if = "Option::is_none")]
    pub cell_size: Option<Kde2dTransformCellSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub counts: Option<Kde2dTransformCounts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<Kde2dTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub size: Kde2dTransformSize,
    #[serde(rename = "type")]
    pub type_: Kde2dTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<Kde2dTransformWeight>,
    pub x: Kde2dTransformX,
    pub y: Kde2dTransformY,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformBandwidth {
    #[educe(Default)]
    Variant0(
        Kde2dTransformBandwidthVariant0,
        Kde2dTransformBandwidthVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformBandwidthVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformCellSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformCounts {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<Kde2dTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformSize {
    #[educe(Default)]
    Variant0(Kde2dTransformSizeVariant0, Kde2dTransformSizeVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum Kde2dTransformType {
    #[educe(Default)]
    #[serde(rename = "kde2d")]
    Kde2d,
}
impl ToString for Kde2dTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Kde2d => "kde2d".to_string(),
        }
    }
}
impl std::str::FromStr for Kde2dTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "kde2d" => Ok(Self::Kde2d),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Kde2dTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Kde2dTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformWeight {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformX {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Kde2dTransformY {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct KdeTransform {
    #[serde(rename = "as", default = "defaults::kde_transform_as")]
    pub as_: KdeTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bandwidth: Option<KdeTransformBandwidth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub counts: Option<KdeTransformCounts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cumulative: Option<KdeTransformCumulative>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<KdeTransformExtent>,
    pub field: KdeTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<KdeTransformGroupby>,
    #[serde(default = "defaults::kde_transform_maxsteps")]
    pub maxsteps: KdeTransformMaxsteps,
    #[serde(default = "defaults::kde_transform_minsteps")]
    pub minsteps: KdeTransformMinsteps,
    #[serde(default = "defaults::kde_transform_resolve")]
    pub resolve: KdeTransformResolve,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<KdeTransformSteps>,
    #[serde(rename = "type")]
    pub type_: KdeTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformAs {
    #[educe(Default)]
    Variant0(Vec<KdeTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformBandwidth {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformCounts {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformCumulative {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformExtent {
    #[educe(Default)]
    Variant0(KdeTransformExtentVariant0, KdeTransformExtentVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformExtentVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<KdeTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformMaxsteps {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformMinsteps {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformResolve {
    #[educe(Default)]
    Variant0(KdeTransformResolveVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum KdeTransformResolveVariant0 {
    #[educe(Default)]
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl ToString for KdeTransformResolveVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Shared => "shared".to_string(),
            Self::Independent => "independent".to_string(),
        }
    }
}
impl std::str::FromStr for KdeTransformResolveVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for KdeTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for KdeTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum KdeTransformSteps {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum KdeTransformType {
    #[educe(Default)]
    #[serde(rename = "kde")]
    Kde,
}
impl ToString for KdeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Kde => "kde".to_string(),
        }
    }
}
impl std::str::FromStr for KdeTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "kde" => Ok(Self::Kde),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for KdeTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for KdeTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelOverlap {
    #[educe(Default)]
    Variant0(bool),
    Variant1(LabelOverlapVariant1),
    Variant2(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LabelOverlapVariant1 {
    #[educe(Default)]
    #[serde(rename = "parity")]
    Parity,
    #[serde(rename = "greedy")]
    Greedy,
}
impl ToString for LabelOverlapVariant1 {
    fn to_string(&self) -> String {
        match *self {
            Self::Parity => "parity".to_string(),
            Self::Greedy => "greedy".to_string(),
        }
    }
}
impl std::str::FromStr for LabelOverlapVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "parity" => Ok(Self::Parity),
            "greedy" => Ok(Self::Greedy),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelOverlapVariant1 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelOverlapVariant1 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelTransform {
    #[serde(default = "defaults::label_transform_anchor")]
    pub anchor: LabelTransformAnchor,
    #[serde(rename = "as", default = "defaults::label_transform_as")]
    pub as_: LabelTransformAs,
    #[serde(
        rename = "avoidBaseMark",
        default = "defaults::label_transform_avoid_base_mark"
    )]
    pub avoid_base_mark: LabelTransformAvoidBaseMark,
    #[serde(
        rename = "avoidMarks",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub avoid_marks: Option<LabelTransformAvoidMarks>,
    #[serde(
        rename = "lineAnchor",
        default = "defaults::label_transform_line_anchor"
    )]
    pub line_anchor: LabelTransformLineAnchor,
    #[serde(rename = "markIndex", default, skip_serializing_if = "Option::is_none")]
    pub mark_index: Option<LabelTransformMarkIndex>,
    #[serde(default = "defaults::label_transform_method")]
    pub method: LabelTransformMethod,
    #[serde(default = "defaults::label_transform_offset")]
    pub offset: LabelTransformOffset,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<LabelTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub size: LabelTransformSize,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: LabelTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformAnchor {
    #[educe(Default)]
    Variant0(Vec<LabelTransformAnchorVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformAnchorVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformAs {
    #[educe(Default)]
    Variant0(
        LabelTransformAsVariant0,
        LabelTransformAsVariant0,
        LabelTransformAsVariant0,
        LabelTransformAsVariant0,
        LabelTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformAvoidBaseMark {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformAvoidMarks {
    #[educe(Default)]
    Variant0(Vec<String>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformLineAnchor {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformMarkIndex {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformMethod {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformOffset {
    #[educe(Default)]
    Variant0(Vec<LabelTransformOffsetVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformOffsetVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformPadding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformSize {
    #[educe(Default)]
    Variant0(LabelTransformSizeVariant0, LabelTransformSizeVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LabelTransformSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LabelTransformType {
    #[educe(Default)]
    #[serde(rename = "label")]
    Label,
}
impl ToString for LabelTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Label => "label".to_string(),
        }
    }
}
impl std::str::FromStr for LabelTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "label" => Ok(Self::Label),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Layout {
    #[educe(Default)]
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<LayoutVariant0Align>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bounds: Option<LayoutVariant0Bounds>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        center: Option<LayoutVariant0Center>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "footerBand",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        footer_band: Option<LayoutVariant0FooterBand>,
        #[serde(
            rename = "headerBand",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        header_band: Option<LayoutVariant0HeaderBand>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LayoutVariant0Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LayoutVariant0Padding>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LayoutVariant0TitleAnchor>,
        #[serde(rename = "titleBand", default, skip_serializing_if = "Option::is_none")]
        title_band: Option<LayoutVariant0TitleBand>,
    },
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Align {
    #[educe(Default)]
    Variant0(LayoutVariant0AlignVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<LayoutVariant0AlignVariant1Column>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<LayoutVariant0AlignVariant1Row>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant0 {
    #[educe(Default)]
    Variant0(LayoutVariant0AlignVariant0Variant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LayoutVariant0AlignVariant0Variant0 {
    #[educe(Default)]
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ToString for LayoutVariant0AlignVariant0Variant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0AlignVariant0Variant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0AlignVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0AlignVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant1Column {
    #[educe(Default)]
    Variant0(LayoutVariant0AlignVariant1ColumnVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LayoutVariant0AlignVariant1ColumnVariant0 {
    #[educe(Default)]
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ToString for LayoutVariant0AlignVariant1ColumnVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant1Row {
    #[educe(Default)]
    Variant0(LayoutVariant0AlignVariant1RowVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LayoutVariant0AlignVariant1RowVariant0 {
    #[educe(Default)]
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ToString for LayoutVariant0AlignVariant1RowVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0AlignVariant1RowVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LayoutVariant0Bounds {
    #[educe(Default)]
    Variant0(LayoutVariant0BoundsVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LayoutVariant0BoundsVariant0 {
    #[educe(Default)]
    #[serde(rename = "full")]
    Full,
    #[serde(rename = "flush")]
    Flush,
}
impl ToString for LayoutVariant0BoundsVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Full => "full".to_string(),
            Self::Flush => "flush".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0BoundsVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "full" => Ok(Self::Full),
            "flush" => Ok(Self::Flush),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0BoundsVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0BoundsVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Center {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<BooleanOrSignal>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0FooterBand {
    #[educe(Default)]
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0HeaderBand {
    #[educe(Default)]
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Offset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2 {
        #[serde(
            rename = "columnFooter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_footer: Option<NumberOrSignal>,
        #[serde(
            rename = "columnHeader",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_header: Option<NumberOrSignal>,
        #[serde(
            rename = "columnTitle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_title: Option<NumberOrSignal>,
        #[serde(rename = "rowFooter", default, skip_serializing_if = "Option::is_none")]
        row_footer: Option<NumberOrSignal>,
        #[serde(rename = "rowHeader", default, skip_serializing_if = "Option::is_none")]
        row_header: Option<NumberOrSignal>,
        #[serde(rename = "rowTitle", default, skip_serializing_if = "Option::is_none")]
        row_title: Option<NumberOrSignal>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Padding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0TitleAnchor {
    #[educe(Default)]
    Variant0(LayoutVariant0TitleAnchorVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<LayoutVariant0TitleAnchorVariant1Column>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<LayoutVariant0TitleAnchorVariant1Row>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant0 {
    #[educe(Default)]
    Variant0(LayoutVariant0TitleAnchorVariant0Variant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LayoutVariant0TitleAnchorVariant0Variant0 {
    #[educe(Default)]
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl ToString for LayoutVariant0TitleAnchorVariant0Variant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant1Column {
    #[educe(Default)]
    Variant0(LayoutVariant0TitleAnchorVariant1ColumnVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    #[educe(Default)]
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl ToString for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant1Row {
    #[educe(Default)]
    Variant0(LayoutVariant0TitleAnchorVariant1RowVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LayoutVariant0TitleAnchorVariant1RowVariant0 {
    #[educe(Default)]
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl ToString for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0TitleBand {
    #[educe(Default)]
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Legend {
    #[serde(flatten)]
    pub subtype_0: LegendSubtype0,
    #[serde(flatten)]
    pub subtype_1: LegendSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendSubtype0 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(
        rename = "clipHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub clip_height: Option<NumberOrSignal>,
    #[serde(
        rename = "columnPadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub column_padding: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub columns: Option<NumberOrSignal>,
    #[serde(
        rename = "cornerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius: Option<LegendSubtype0CornerRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub direction: Option<LegendSubtype0Direction>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<LegendSubtype0Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fill: Option<String>,
    #[serde(rename = "fillColor", default, skip_serializing_if = "Option::is_none")]
    pub fill_color: Option<LegendSubtype0FillColor>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<LegendSubtype0Format>,
    #[serde(
        rename = "formatType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub format_type: Option<LegendSubtype0FormatType>,
    #[serde(
        rename = "gradientLength",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_length: Option<NumberOrSignal>,
    #[serde(
        rename = "gradientOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_opacity: Option<LegendSubtype0GradientOpacity>,
    #[serde(
        rename = "gradientStrokeColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_stroke_color: Option<LegendSubtype0GradientStrokeColor>,
    #[serde(
        rename = "gradientStrokeWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_stroke_width: Option<LegendSubtype0GradientStrokeWidth>,
    #[serde(
        rename = "gradientThickness",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_thickness: Option<NumberOrSignal>,
    #[serde(rename = "gridAlign", default, skip_serializing_if = "Option::is_none")]
    pub grid_align: Option<LegendSubtype0GridAlign>,
    #[serde(
        rename = "labelAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_align: Option<LegendSubtype0LabelAlign>,
    #[serde(
        rename = "labelBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_baseline: Option<LegendSubtype0LabelBaseline>,
    #[serde(
        rename = "labelColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_color: Option<LegendSubtype0LabelColor>,
    #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
    pub label_font: Option<LegendSubtype0LabelFont>,
    #[serde(
        rename = "labelFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_size: Option<LegendSubtype0LabelFontSize>,
    #[serde(
        rename = "labelFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_style: Option<LegendSubtype0LabelFontStyle>,
    #[serde(
        rename = "labelFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_weight: Option<LegendSubtype0LabelFontWeight>,
    #[serde(
        rename = "labelLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_limit: Option<LegendSubtype0LabelLimit>,
    #[serde(
        rename = "labelOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_offset: Option<LegendSubtype0LabelOffset>,
    #[serde(
        rename = "labelOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_opacity: Option<LegendSubtype0LabelOpacity>,
    #[serde(
        rename = "labelOverlap",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_overlap: Option<LabelOverlap>,
    #[serde(
        rename = "labelSeparation",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_separation: Option<NumberOrSignal>,
    #[serde(rename = "legendX", default, skip_serializing_if = "Option::is_none")]
    pub legend_x: Option<LegendSubtype0LegendX>,
    #[serde(rename = "legendY", default, skip_serializing_if = "Option::is_none")]
    pub legend_y: Option<LegendSubtype0LegendY>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<LegendSubtype0Offset>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opacity: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub orient: Option<LegendSubtype0Orient>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<LegendSubtype0Padding>,
    #[serde(
        rename = "rowPadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub row_padding: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shape: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stroke: Option<String>,
    #[serde(
        rename = "strokeColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_color: Option<LegendSubtype0StrokeColor>,
    #[serde(
        rename = "strokeDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_dash: Option<String>,
    #[serde(
        rename = "strokeWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_width: Option<String>,
    #[serde(
        rename = "symbolDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_dash: Option<LegendSubtype0SymbolDash>,
    #[serde(
        rename = "symbolDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_dash_offset: Option<LegendSubtype0SymbolDashOffset>,
    #[serde(
        rename = "symbolFillColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_fill_color: Option<LegendSubtype0SymbolFillColor>,
    #[serde(
        rename = "symbolLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_limit: Option<NumberOrSignal>,
    #[serde(
        rename = "symbolOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_offset: Option<LegendSubtype0SymbolOffset>,
    #[serde(
        rename = "symbolOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_opacity: Option<LegendSubtype0SymbolOpacity>,
    #[serde(
        rename = "symbolSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_size: Option<LegendSubtype0SymbolSize>,
    #[serde(
        rename = "symbolStrokeColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_stroke_color: Option<LegendSubtype0SymbolStrokeColor>,
    #[serde(
        rename = "symbolStrokeWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_stroke_width: Option<LegendSubtype0SymbolStrokeWidth>,
    #[serde(
        rename = "symbolType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_type: Option<LegendSubtype0SymbolType>,
    #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
    pub tick_count: Option<TickCount>,
    #[serde(
        rename = "tickMinStep",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_min_step: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<TextOrSignal>,
    #[serde(
        rename = "titleAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_align: Option<LegendSubtype0TitleAlign>,
    #[serde(
        rename = "titleAnchor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_anchor: Option<LegendSubtype0TitleAnchor>,
    #[serde(
        rename = "titleBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_baseline: Option<LegendSubtype0TitleBaseline>,
    #[serde(
        rename = "titleColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_color: Option<LegendSubtype0TitleColor>,
    #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
    pub title_font: Option<LegendSubtype0TitleFont>,
    #[serde(
        rename = "titleFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_size: Option<LegendSubtype0TitleFontSize>,
    #[serde(
        rename = "titleFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_style: Option<LegendSubtype0TitleFontStyle>,
    #[serde(
        rename = "titleFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_weight: Option<LegendSubtype0TitleFontWeight>,
    #[serde(
        rename = "titleLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_limit: Option<LegendSubtype0TitleLimit>,
    #[serde(
        rename = "titleLineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_line_height: Option<LegendSubtype0TitleLineHeight>,
    #[serde(
        rename = "titleOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_opacity: Option<LegendSubtype0TitleOpacity>,
    #[serde(
        rename = "titleOrient",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_orient: Option<LegendSubtype0TitleOrient>,
    #[serde(
        rename = "titlePadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_padding: Option<LegendSubtype0TitlePadding>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<LegendSubtype0Type>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ArrayOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zindex: Option<f64>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0CornerRadius {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0Direction {
    #[educe(Default)]
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl ToString for LegendSubtype0Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Vertical => "vertical".to_string(),
            Self::Horizontal => "horizontal".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0Direction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0Direction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0Direction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendSubtype0Encode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gradient: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub legend: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0FillColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendSubtype0Format {
    #[educe(Default)]
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0FormatType {
    #[educe(Default)]
    Variant0(LegendSubtype0FormatTypeVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0FormatTypeVariant0 {
    #[educe(Default)]
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ToString for LegendSubtype0FormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0FormatTypeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0FormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0FormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0GradientOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0GradientStrokeColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0GradientStrokeWidth {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0GridAlign {
    #[educe(Default)]
    Variant0(LegendSubtype0GridAlignVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0GridAlignVariant0 {
    #[educe(Default)]
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ToString for LegendSubtype0GridAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0GridAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0GridAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0GridAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelAlign {
    #[educe(Default)]
    Variant0(LegendSubtype0LabelAlignVariant0),
    Variant1(AlignValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0LabelAlignVariant0 {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ToString for LegendSubtype0LabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0LabelAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0LabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0LabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelBaseline {
    #[educe(Default)]
    Variant0(LegendSubtype0LabelBaselineVariant0),
    Variant1(BaselineValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0LabelBaselineVariant0 {
    #[educe(Default)]
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ToString for LegendSubtype0LabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0LabelBaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0LabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0LabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelFont {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelFontSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelFontStyle {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelFontWeight {
    #[educe(Default)]
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelLimit {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LabelOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LegendX {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0LegendY {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0Offset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0Orient {
    #[educe(Default)]
    Variant0(LegendSubtype0OrientVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0OrientVariant0 {
    #[educe(Default)]
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl ToString for LegendSubtype0OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::TopLeft => "top-left".to_string(),
            Self::TopRight => "top-right".to_string(),
            Self::BottomLeft => "bottom-left".to_string(),
            Self::BottomRight => "bottom-right".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0OrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0Padding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0StrokeColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolDash {
    #[educe(Default)]
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolDashOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolFillColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolStrokeColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolStrokeWidth {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolType {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleAlign {
    #[educe(Default)]
    Variant0(LegendSubtype0TitleAlignVariant0),
    Variant1(AlignValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0TitleAlignVariant0 {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ToString for LegendSubtype0TitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0TitleAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0TitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0TitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleAnchor {
    #[educe(Default)]
    Variant0(Option<LegendSubtype0TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0TitleAnchorVariant0 {
    #[educe(Default)]
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ToString for LegendSubtype0TitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0TitleAnchorVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0TitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0TitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleBaseline {
    #[educe(Default)]
    Variant0(LegendSubtype0TitleBaselineVariant0),
    Variant1(BaselineValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0TitleBaselineVariant0 {
    #[educe(Default)]
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ToString for LegendSubtype0TitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0TitleBaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0TitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0TitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleFont {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleFontSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleFontStyle {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleFontWeight {
    #[educe(Default)]
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleLimit {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleLineHeight {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleOpacity {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitleOrient {
    #[educe(Default)]
    Variant0(LegendSubtype0TitleOrientVariant0),
    Variant1(OrientValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0TitleOrientVariant0 {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ToString for LegendSubtype0TitleOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0TitleOrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0TitleOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0TitleOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype0TitlePadding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LegendSubtype0Type {
    #[educe(Default)]
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl ToString for LegendSubtype0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Gradient => "gradient".to_string(),
            Self::Symbol => "symbol".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LegendSubtype1 {
    #[educe(Default)]
    Variant0 {},
    Variant1 {},
    Variant2 {},
    Variant3 {},
    Variant4 {},
    Variant5 {},
    Variant6 {},
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LinearGradient {
    pub gradient: LinearGradientGradient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    pub stops: GradientStops,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x2: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y2: Option<f64>,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LinearGradientGradient {
    #[educe(Default)]
    #[serde(rename = "linear")]
    Linear,
}
impl ToString for LinearGradientGradient {
    fn to_string(&self) -> String {
        match *self {
            Self::Linear => "linear".to_string(),
        }
    }
}
impl std::str::FromStr for LinearGradientGradient {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "linear" => Ok(Self::Linear),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LinearGradientGradient {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinearGradientGradient {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LinkpathTransform {
    #[serde(rename = "as", default = "defaults::linkpath_transform_as")]
    pub as_: LinkpathTransformAs,
    #[serde(default = "defaults::linkpath_transform_orient")]
    pub orient: LinkpathTransformOrient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub require: Option<SignalRef>,
    #[serde(default = "defaults::linkpath_transform_shape")]
    pub shape: LinkpathTransformShape,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "sourceX", default = "defaults::linkpath_transform_source_x")]
    pub source_x: LinkpathTransformSourceX,
    #[serde(rename = "sourceY", default = "defaults::linkpath_transform_source_y")]
    pub source_y: LinkpathTransformSourceY,
    #[serde(rename = "targetX", default = "defaults::linkpath_transform_target_x")]
    pub target_x: LinkpathTransformTargetX,
    #[serde(rename = "targetY", default = "defaults::linkpath_transform_target_y")]
    pub target_y: LinkpathTransformTargetY,
    #[serde(rename = "type")]
    pub type_: LinkpathTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LinkpathTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LinkpathTransformOrient {
    #[educe(Default)]
    Variant0(LinkpathTransformOrientVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LinkpathTransformOrientVariant0 {
    #[educe(Default)]
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "radial")]
    Radial,
}
impl ToString for LinkpathTransformOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Horizontal => "horizontal".to_string(),
            Self::Vertical => "vertical".to_string(),
            Self::Radial => "radial".to_string(),
        }
    }
}
impl std::str::FromStr for LinkpathTransformOrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            "radial" => Ok(Self::Radial),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LinkpathTransformOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinkpathTransformOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LinkpathTransformShape {
    #[educe(Default)]
    Variant0(LinkpathTransformShapeVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LinkpathTransformShapeVariant0 {
    #[educe(Default)]
    #[serde(rename = "line")]
    Line,
    #[serde(rename = "arc")]
    Arc,
    #[serde(rename = "curve")]
    Curve,
    #[serde(rename = "diagonal")]
    Diagonal,
    #[serde(rename = "orthogonal")]
    Orthogonal,
}
impl ToString for LinkpathTransformShapeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Line => "line".to_string(),
            Self::Arc => "arc".to_string(),
            Self::Curve => "curve".to_string(),
            Self::Diagonal => "diagonal".to_string(),
            Self::Orthogonal => "orthogonal".to_string(),
        }
    }
}
impl std::str::FromStr for LinkpathTransformShapeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "line" => Ok(Self::Line),
            "arc" => Ok(Self::Arc),
            "curve" => Ok(Self::Curve),
            "diagonal" => Ok(Self::Diagonal),
            "orthogonal" => Ok(Self::Orthogonal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LinkpathTransformShapeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinkpathTransformShapeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LinkpathTransformSourceX {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LinkpathTransformSourceY {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LinkpathTransformTargetX {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LinkpathTransformTargetY {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LinkpathTransformType {
    #[educe(Default)]
    #[serde(rename = "linkpath")]
    Linkpath,
}
impl ToString for LinkpathTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Linkpath => "linkpath".to_string(),
        }
    }
}
impl std::str::FromStr for LinkpathTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "linkpath" => Ok(Self::Linkpath),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LinkpathTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinkpathTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Listener {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        scale: String,
    },
    Variant2(Stream),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LoessTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<LoessTransformAs>,
    #[serde(default = "defaults::loess_transform_bandwidth")]
    pub bandwidth: LoessTransformBandwidth,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<LoessTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: LoessTransformType,
    pub x: LoessTransformX,
    pub y: LoessTransformY,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LoessTransformAs {
    #[educe(Default)]
    Variant0(Vec<LoessTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LoessTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LoessTransformBandwidth {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LoessTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<LoessTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LoessTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LoessTransformType {
    #[educe(Default)]
    #[serde(rename = "loess")]
    Loess,
}
impl ToString for LoessTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Loess => "loess".to_string(),
        }
    }
}
impl std::str::FromStr for LoessTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "loess" => Ok(Self::Loess),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LoessTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LoessTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LoessTransformX {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LoessTransformY {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LookupTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<LookupTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    pub fields: LookupTransformFields,
    pub from: String,
    pub key: LookupTransformKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: LookupTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<LookupTransformValues>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LookupTransformAs {
    #[educe(Default)]
    Variant0(Vec<LookupTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LookupTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LookupTransformFields {
    #[educe(Default)]
    Variant0(Vec<LookupTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LookupTransformFieldsVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LookupTransformKey {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum LookupTransformType {
    #[educe(Default)]
    #[serde(rename = "lookup")]
    Lookup,
}
impl ToString for LookupTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Lookup => "lookup".to_string(),
        }
    }
}
impl std::str::FromStr for LookupTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "lookup" => Ok(Self::Lookup),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LookupTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LookupTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LookupTransformValues {
    #[educe(Default)]
    Variant0(Vec<LookupTransformValuesVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum LookupTransformValuesVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Mark {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clip: Option<Markclip>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interactive: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub on: Option<OnMarkTrigger>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub transform: Vec<TransformMark>,
    #[serde(rename = "type")]
    pub type_: Marktype,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct MarkGroup {
    #[serde(flatten)]
    pub mark: Mark,
    #[serde(flatten)]
    pub scope: Scope,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<MarkGroupFrom>,
    #[serde(rename = "type")]
    pub type_: MarkGroupType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum MarkGroupFrom {
    #[educe(Default)]
    From(From),
    Facet(Facet),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum MarkGroupType {
    #[educe(Default)]
    #[serde(rename = "group")]
    Group,
}
impl ToString for MarkGroupType {
    fn to_string(&self) -> String {
        match *self {
            Self::Group => "group".to_string(),
        }
    }
}
impl std::str::FromStr for MarkGroupType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "group" => Ok(Self::Group),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarkGroupType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarkGroupType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct MarkVisual {
    #[serde(flatten)]
    pub mark: Mark,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<From>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarkVisualType>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct MarkVisualType(String);
impl std::ops::Deref for MarkVisualType {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::convert::TryFrom<String> for MarkVisualType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        if ["group".to_string()].contains(&value) {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Markclip {
    #[educe(Default)]
    Variant0(BooleanOrSignal),
    Variant1 {
        path: StringOrSignal,
    },
    Variant2 {
        sphere: StringOrSignal,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Marktype(pub String);
impl std::ops::Deref for Marktype {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NestTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generate: Option<NestTransformGenerate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keys: Option<NestTransformKeys>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: NestTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NestTransformGenerate {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NestTransformKeys {
    #[educe(Default)]
    Variant0(Vec<NestTransformKeysVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NestTransformKeysVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum NestTransformType {
    #[educe(Default)]
    #[serde(rename = "nest")]
    Nest,
}
impl ToString for NestTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Nest => "nest".to_string(),
        }
    }
}
impl std::str::FromStr for NestTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "nest" => Ok(Self::Nest),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for NestTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NestTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberModifiers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub band: Option<NumberModifiersBand>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exponent: Option<NumberModifiersExponent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mult: Option<NumberModifiersMult>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<NumberModifiersOffset>,
    #[serde(default)]
    pub round: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<Field>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberModifiersBand {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberModifiersExponent {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberModifiersMult {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberModifiersOffset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberOrSignal {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberValue {
    #[educe(Default)]
    Variant0(Vec<NumberValueVariant0Item>),
    Variant1(NumberValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: NumberValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: NumberModifiers,
    #[serde(flatten)]
    pub subtype_1: NumberValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<NumberValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<NumberValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<NumberValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<NumberValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: f64,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: NumberModifiers,
    #[serde(flatten)]
    pub subtype_1: NumberValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<NumberValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<NumberValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<NumberValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<NumberValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: f64,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: NumberValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum NumberValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct NumberValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OnEvents(pub Vec<OnEventsItem>);
impl std::ops::Deref for OnEvents {
    type Target = Vec<OnEventsItem>;
    fn deref(&self) -> &Vec<OnEventsItem> {
        &self.0
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OnEventsItem {
    #[serde(flatten)]
    pub subtype_0: OnEventsItemSubtype0,
    #[serde(flatten)]
    pub subtype_1: OnEventsItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OnEventsItemSubtype0 {
    pub events: OnEventsItemSubtype0Events,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum OnEventsItemSubtype0Events {
    #[educe(Default)]
    Variant0(Selector),
    Variant1(Listener),
    Variant2(Vec<Listener>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
pub enum OnEventsItemSubtype1 {
    #[educe(Default)]
    #[serde(rename = "encode")]
    Encode(String),
    #[serde(rename = "update")]
    Update(OnEventsItemSubtype1Update),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum OnEventsItemSubtype1Update {
    #[educe(Default)]
    Variant0(ExprString),
    Variant1(Expr),
    Variant2(SignalRef),
    Variant3 {
        value: serde_json::Value,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OnMarkTrigger(pub Vec<OnMarkTriggerItem>);
impl std::ops::Deref for OnMarkTrigger {
    type Target = Vec<OnMarkTriggerItem>;
    fn deref(&self) -> &Vec<OnMarkTriggerItem> {
        &self.0
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OnMarkTriggerItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modify: Option<ExprString>,
    pub trigger: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ExprString>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OnTrigger(pub Vec<OnTriggerItem>);
impl std::ops::Deref for OnTrigger {
    type Target = Vec<OnTriggerItem>;
    fn deref(&self) -> &Vec<OnTriggerItem> {
        &self.0
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OnTriggerItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insert: Option<ExprString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modify: Option<ExprString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<OnTriggerItemRemove>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub toggle: Option<ExprString>,
    pub trigger: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ExprString>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum OnTriggerItemRemove {
    #[educe(Default)]
    Variant0(bool),
    Variant1(ExprString),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum OrientValue {
    #[educe(Default)]
    Variant0(Vec<OrientValueVariant0Item>),
    Variant1(OrientValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: OrientValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: OrientValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<OrientValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<OrientValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<OrientValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<OrientValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum OrientValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ToString for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: OrientValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<OrientValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<OrientValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<OrientValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<OrientValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum OrientValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: OrientValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: OrientValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum OrientValueVariant1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ToString for OrientValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for OrientValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrientValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum OrientValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct OrientValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackTransform {
    #[serde(rename = "as", default = "defaults::pack_transform_as")]
    pub as_: PackTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<PackTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<PackTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub radius: Option<PackTransformRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<PackTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: PackTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PackTransformAs {
    #[educe(Default)]
    Variant0(
        PackTransformAsVariant0,
        PackTransformAsVariant0,
        PackTransformAsVariant0,
        PackTransformAsVariant0,
        PackTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PackTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PackTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PackTransformPadding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PackTransformRadius {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PackTransformSize {
    #[educe(Default)]
    Variant0(PackTransformSizeVariant0, PackTransformSizeVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PackTransformSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PackTransformType {
    #[educe(Default)]
    #[serde(rename = "pack")]
    Pack,
}
impl ToString for PackTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Pack => "pack".to_string(),
        }
    }
}
impl std::str::FromStr for PackTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pack" => Ok(Self::Pack),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PackTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PackTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Padding {
    #[educe(Default)]
    Variant0(f64),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bottom: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        left: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        right: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        top: Option<f64>,
    },
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ParamField {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<String>,
    pub field: String,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PartitionTransform {
    #[serde(rename = "as", default = "defaults::partition_transform_as")]
    pub as_: PartitionTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<PartitionTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<PartitionTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub round: Option<PartitionTransformRound>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<PartitionTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: PartitionTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PartitionTransformAs {
    #[educe(Default)]
    Variant0(
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PartitionTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PartitionTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PartitionTransformPadding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PartitionTransformRound {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PartitionTransformSize {
    #[educe(Default)]
    Variant0(
        PartitionTransformSizeVariant0,
        PartitionTransformSizeVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PartitionTransformSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PartitionTransformType {
    #[educe(Default)]
    #[serde(rename = "partition")]
    Partition,
}
impl ToString for PartitionTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Partition => "partition".to_string(),
        }
    }
}
impl std::str::FromStr for PartitionTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "partition" => Ok(Self::Partition),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PartitionTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PartitionTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PieTransform {
    #[serde(rename = "as", default = "defaults::pie_transform_as")]
    pub as_: PieTransformAs,
    #[serde(rename = "endAngle", default = "defaults::pie_transform_end_angle")]
    pub end_angle: PieTransformEndAngle,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<PieTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<PieTransformSort>,
    #[serde(
        rename = "startAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub start_angle: Option<PieTransformStartAngle>,
    #[serde(rename = "type")]
    pub type_: PieTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PieTransformAs {
    #[educe(Default)]
    Variant0(PieTransformAsVariant0, PieTransformAsVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PieTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PieTransformEndAngle {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PieTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PieTransformSort {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PieTransformStartAngle {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PieTransformType {
    #[educe(Default)]
    #[serde(rename = "pie")]
    Pie,
}
impl ToString for PieTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Pie => "pie".to_string(),
        }
    }
}
impl std::str::FromStr for PieTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pie" => Ok(Self::Pie),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PieTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PieTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PivotTransform {
    pub field: PivotTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<PivotTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<PivotTransformKey>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limit: Option<PivotTransformLimit>,
    #[serde(default = "defaults::pivot_transform_op")]
    pub op: PivotTransformOp,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: PivotTransformType,
    pub value: PivotTransformValue,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PivotTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PivotTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<PivotTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PivotTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PivotTransformKey {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PivotTransformLimit {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PivotTransformOp {
    #[educe(Default)]
    Variant0(PivotTransformOpVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PivotTransformOpVariant0 {
    #[educe(Default)]
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl ToString for PivotTransformOpVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for PivotTransformOpVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PivotTransformOpVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PivotTransformOpVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum PivotTransformType {
    #[educe(Default)]
    #[serde(rename = "pivot")]
    Pivot,
}
impl ToString for PivotTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Pivot => "pivot".to_string(),
        }
    }
}
impl std::str::FromStr for PivotTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pivot" => Ok(Self::Pivot),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PivotTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PivotTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum PivotTransformValue {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<ProjectTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<ProjectTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ProjectTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectTransformAs {
    #[educe(Default)]
    Variant0(Vec<ProjectTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectTransformFields {
    #[educe(Default)]
    Variant0(Vec<ProjectTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectTransformFieldsVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ProjectTransformType {
    #[educe(Default)]
    #[serde(rename = "project")]
    Project,
}
impl ToString for ProjectTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Project => "project".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "project" => Ok(Self::Project),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Projection {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub center: Option<ProjectionCenter>,
    #[serde(rename = "clipAngle", default, skip_serializing_if = "Option::is_none")]
    pub clip_angle: Option<NumberOrSignal>,
    #[serde(
        rename = "clipExtent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub clip_extent: Option<ProjectionClipExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<ProjectionExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fit: Option<ProjectionFit>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallels: Option<ProjectionParallels>,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub point_radius: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub precision: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotate: Option<ProjectionRotate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<ProjectionSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<ProjectionTranslate>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StringOrSignal>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionCenter {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionClipExtent {
    #[educe(Default)]
    Variant0(ProjectionClipExtentVariant0, ProjectionClipExtentVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionClipExtentVariant0 {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionExtent {
    #[educe(Default)]
    Variant0(ProjectionExtentVariant0, ProjectionExtentVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionExtentVariant0 {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionFit {
    #[educe(Default)]
    Variant0(std::collections::HashMap<String, serde_json::Value>),
    Variant1(Vec<serde_json::Value>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionParallels {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionRotate {
    #[educe(Default)]
    Variant0(Vec<NumberOrSignal>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionSize {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ProjectionTranslate {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct QuantileTransform {
    #[serde(rename = "as", default = "defaults::quantile_transform_as")]
    pub as_: QuantileTransformAs,
    pub field: QuantileTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<QuantileTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probs: Option<QuantileTransformProbs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::quantile_transform_step")]
    pub step: QuantileTransformStep,
    #[serde(rename = "type")]
    pub type_: QuantileTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum QuantileTransformAs {
    #[educe(Default)]
    Variant0(Vec<QuantileTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum QuantileTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum QuantileTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum QuantileTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<QuantileTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum QuantileTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum QuantileTransformProbs {
    #[educe(Default)]
    Variant0(Vec<QuantileTransformProbsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum QuantileTransformProbsVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum QuantileTransformStep {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum QuantileTransformType {
    #[educe(Default)]
    #[serde(rename = "quantile")]
    Quantile,
}
impl ToString for QuantileTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Quantile => "quantile".to_string(),
        }
    }
}
impl std::str::FromStr for QuantileTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "quantile" => Ok(Self::Quantile),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for QuantileTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for QuantileTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RadialGradient {
    pub gradient: RadialGradientGradient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub r1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub r2: Option<f64>,
    pub stops: GradientStops,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x2: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y2: Option<f64>,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RadialGradientGradient {
    #[educe(Default)]
    #[serde(rename = "radial")]
    Radial,
}
impl ToString for RadialGradientGradient {
    fn to_string(&self) -> String {
        match *self {
            Self::Radial => "radial".to_string(),
        }
    }
}
impl std::str::FromStr for RadialGradientGradient {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "radial" => Ok(Self::Radial),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RadialGradientGradient {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RadialGradientGradient {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegressionTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<RegressionTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<RegressionTransformExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<RegressionTransformGroupby>,
    #[serde(default = "defaults::regression_transform_method")]
    pub method: RegressionTransformMethod,
    #[serde(default = "defaults::regression_transform_order")]
    pub order: RegressionTransformOrder,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<RegressionTransformParams>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: RegressionTransformType,
    pub x: RegressionTransformX,
    pub y: RegressionTransformY,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformAs {
    #[educe(Default)]
    Variant0(Vec<RegressionTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformExtent {
    #[educe(Default)]
    Variant0(
        RegressionTransformExtentVariant0,
        RegressionTransformExtentVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformExtentVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<RegressionTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformMethod {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformOrder {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformParams {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum RegressionTransformType {
    #[educe(Default)]
    #[serde(rename = "regression")]
    Regression,
}
impl ToString for RegressionTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Regression => "regression".to_string(),
        }
    }
}
impl std::str::FromStr for RegressionTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "regression" => Ok(Self::Regression),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RegressionTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RegressionTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformX {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum RegressionTransformY {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ResolvefilterTransform {
    pub filter: serde_json::Value,
    pub ignore: ResolvefilterTransformIgnore,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ResolvefilterTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ResolvefilterTransformIgnore {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ResolvefilterTransformType {
    #[educe(Default)]
    #[serde(rename = "resolvefilter")]
    Resolvefilter,
}
impl ToString for ResolvefilterTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolvefilter => "resolvefilter".to_string(),
        }
    }
}
impl std::str::FromStr for ResolvefilterTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolvefilter" => Ok(Self::Resolvefilter),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ResolvefilterTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ResolvefilterTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Rule {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test: Option<String>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SampleTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::sample_transform_size")]
    pub size: SampleTransformSize,
    #[serde(rename = "type")]
    pub type_: SampleTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum SampleTransformSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SampleTransformType {
    #[educe(Default)]
    #[serde(rename = "sample")]
    Sample,
}
impl ToString for SampleTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Sample => "sample".to_string(),
        }
    }
}
impl std::str::FromStr for SampleTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "sample" => Ok(Self::Sample),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SampleTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SampleTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Scale {
    #[educe(Default)]
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant0Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant0DomainRaw>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant1Domain>,
        #[serde(
            rename = "domainImplicit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        domain_implicit: Option<BooleanOrSignal>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant1DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant1Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant1Type,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant2Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant2DomainRaw>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(
            rename = "paddingInner",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        padding_inner: Option<NumberOrSignal>,
        #[serde(
            rename = "paddingOuter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        padding_outer: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant2Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant2Type,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant3Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant3DomainRaw>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(
            rename = "paddingOuter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        padding_outer: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant3Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant3Type,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant4Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant4DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant4Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant4Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant4Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant5 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant5Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant5DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant5Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant5Type,
    },
    Variant6 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant6Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant6DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant6Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant6Type,
    },
    Variant7 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant7Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant7DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant7Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant7Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant7Type,
    },
    Variant8 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant8Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant8DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant8Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant8Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<ScaleVariant8Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant9 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        base: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant9Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant9DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant9Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant9Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant9Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant10 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant10Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant10DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant10Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant10Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant10Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant11 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        constant: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant11Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant11DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant11Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant11Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant11Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleBins {
    #[educe(Default)]
    Variant0(Vec<NumberOrSignal>),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        start: Option<NumberOrSignal>,
        step: NumberOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        stop: Option<NumberOrSignal>,
    },
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleData {
    #[educe(Default)]
    Variant0 {
        data: String,
        field: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleDataVariant0Sort>,
    },
    Variant1 {
        data: String,
        fields: Vec<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleDataVariant1Sort>,
    },
    Variant2 {
        fields: Vec<ScaleDataVariant2FieldsItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleDataVariant2Sort>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant0Sort {
    #[educe(Default)]
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        field: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant1Sort {
    #[educe(Default)]
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleDataVariant1SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleDataVariant1SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleDataVariant1SortVariant1Op {
    #[educe(Default)]
    #[serde(rename = "count")]
    Count,
}
impl ToString for ScaleDataVariant1SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant1SortVariant1Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleDataVariant1SortVariant2Op {
    #[educe(Default)]
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl ToString for ScaleDataVariant1SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant1SortVariant2Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant2FieldsItem {
    #[educe(Default)]
    Variant0 {
        data: String,
        field: StringOrSignal,
    },
    Variant1(Vec<ScaleDataVariant2FieldsItemVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleDataVariant2FieldsItemVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(f64),
    Variant2(bool),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant2Sort {
    #[educe(Default)]
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleDataVariant2SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleDataVariant2SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleDataVariant2SortVariant1Op {
    #[educe(Default)]
    #[serde(rename = "count")]
    Count,
}
impl ToString for ScaleDataVariant2SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant2SortVariant1Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleDataVariant2SortVariant2Op {
    #[educe(Default)]
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl ToString for ScaleDataVariant2SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant2SortVariant2Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct ScaleField(pub StringOrSignal);
impl std::ops::Deref for ScaleField {
    type Target = StringOrSignal;
    fn deref(&self) -> &StringOrSignal {
        &self.0
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleInterpolate {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        gamma: Option<NumberOrSignal>,
        #[serde(rename = "type")]
        type_: StringOrSignal,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant0Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant0DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant0DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant0DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant0Type {
    #[educe(Default)]
    #[serde(rename = "identity")]
    Identity,
}
impl ToString for ScaleVariant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Identity => "identity".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant0Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "identity" => Ok(Self::Identity),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant0Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant0Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant10Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant10DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant10DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant10DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant10Nice {
    #[educe(Default)]
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant10Range {
    #[educe(Default)]
    Variant0(ScaleVariant10RangeVariant0),
    Variant1(Vec<ScaleVariant10RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant10RangeVariant2Extent>,
        scheme: ScaleVariant10RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant10RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant10RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant10RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant10RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant10RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2Extent {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2Scheme {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<ScaleVariant10RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2SchemeVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant10Type {
    #[educe(Default)]
    #[serde(rename = "pow")]
    Pow,
}
impl ToString for ScaleVariant10Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Pow => "pow".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant10Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pow" => Ok(Self::Pow),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant10Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant10Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant11Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant11DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant11DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant11DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant11Nice {
    #[educe(Default)]
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant11Range {
    #[educe(Default)]
    Variant0(ScaleVariant11RangeVariant0),
    Variant1(Vec<ScaleVariant11RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant11RangeVariant2Extent>,
        scheme: ScaleVariant11RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant11RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant11RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant11RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant11RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant11RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2Extent {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2Scheme {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<ScaleVariant11RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2SchemeVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant11Type {
    #[educe(Default)]
    #[serde(rename = "symlog")]
    Symlog,
}
impl ToString for ScaleVariant11Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Symlog => "symlog".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant11Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "symlog" => Ok(Self::Symlog),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant11Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant11Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant1Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant1DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant1DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant1DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1Range {
    #[educe(Default)]
    Variant0(ScaleVariant1RangeVariant0),
    Variant1(Vec<ScaleVariant1RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant1RangeVariant2Extent>,
        scheme: ScaleVariant1RangeVariant2Scheme,
    },
    Variant3(ScaleVariant1RangeVariant3),
    Variant4(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant1RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant1RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2Extent {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2Scheme {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<ScaleVariant1RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2SchemeVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3 {
    #[educe(Default)]
    Variant0 {
        data: String,
        field: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleVariant1RangeVariant3Variant0Sort>,
    },
    Variant1 {
        data: String,
        fields: Vec<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleVariant1RangeVariant3Variant1Sort>,
    },
    Variant2 {
        fields: Vec<ScaleVariant1RangeVariant3Variant2FieldsItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleVariant1RangeVariant3Variant2Sort>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant0Sort {
    #[educe(Default)]
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        field: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant1Sort {
    #[educe(Default)]
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleVariant1RangeVariant3Variant1SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleVariant1RangeVariant3Variant1SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    #[educe(Default)]
    #[serde(rename = "count")]
    Count,
}
impl ToString for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    #[educe(Default)]
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl ToString for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant2FieldsItem {
    #[educe(Default)]
    Variant0 {
        data: String,
        field: StringOrSignal,
    },
    Variant1(Vec<ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(f64),
    Variant2(bool),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant2Sort {
    #[educe(Default)]
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleVariant1RangeVariant3Variant2SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleVariant1RangeVariant3Variant2SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    #[educe(Default)]
    #[serde(rename = "count")]
    Count,
}
impl ToString for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    #[educe(Default)]
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl ToString for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant1Type {
    #[educe(Default)]
    #[serde(rename = "ordinal")]
    Ordinal,
}
impl ToString for ScaleVariant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Ordinal => "ordinal".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "ordinal" => Ok(Self::Ordinal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant2Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant2DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant2DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant2DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant2Range {
    #[educe(Default)]
    Variant0(ScaleVariant2RangeVariant0),
    Variant1(Vec<ScaleVariant2RangeVariant1Item>),
    Variant2 {
        step: NumberOrSignal,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant2RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant2RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant2RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant2RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant2RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant2RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant2Type {
    #[educe(Default)]
    #[serde(rename = "band")]
    Band,
}
impl ToString for ScaleVariant2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Band => "band".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant2Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "band" => Ok(Self::Band),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant2Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant2Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant3Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant3DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant3DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant3DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant3Range {
    #[educe(Default)]
    Variant0(ScaleVariant3RangeVariant0),
    Variant1(Vec<ScaleVariant3RangeVariant1Item>),
    Variant2 {
        step: NumberOrSignal,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant3RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant3RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant3RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant3RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant3RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant3RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant3Type {
    #[educe(Default)]
    #[serde(rename = "point")]
    Point,
}
impl ToString for ScaleVariant3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Point => "point".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant3Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "point" => Ok(Self::Point),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant3Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant3Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant4Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant4DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant4DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant4DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant4Nice {
    #[educe(Default)]
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant4Range {
    #[educe(Default)]
    Variant0(ScaleVariant4RangeVariant0),
    Variant1(Vec<ScaleVariant4RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant4RangeVariant2Extent>,
        scheme: ScaleVariant4RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant4RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant4RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant4RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant4RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant4RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2Extent {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2Scheme {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<ScaleVariant4RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2SchemeVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant4Type {
    #[educe(Default)]
    #[serde(rename = "quantize")]
    Quantize,
    #[serde(rename = "threshold")]
    Threshold,
}
impl ToString for ScaleVariant4Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Quantize => "quantize".to_string(),
            Self::Threshold => "threshold".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant4Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "quantize" => Ok(Self::Quantize),
            "threshold" => Ok(Self::Threshold),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant4Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant4Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant5Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant5DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant5DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant5DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant5Range {
    #[educe(Default)]
    Variant0(ScaleVariant5RangeVariant0),
    Variant1(Vec<ScaleVariant5RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant5RangeVariant2Extent>,
        scheme: ScaleVariant5RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant5RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant5RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant5RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant5RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant5RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2Extent {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2Scheme {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<ScaleVariant5RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2SchemeVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant5Type {
    #[educe(Default)]
    #[serde(rename = "quantile")]
    Quantile,
}
impl ToString for ScaleVariant5Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Quantile => "quantile".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant5Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "quantile" => Ok(Self::Quantile),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant5Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant5Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant6Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant6DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant6DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant6DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant6Range {
    #[educe(Default)]
    Variant0(ScaleVariant6RangeVariant0),
    Variant1(Vec<ScaleVariant6RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant6RangeVariant2Extent>,
        scheme: ScaleVariant6RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant6RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant6RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant6RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant6RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant6RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2Extent {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2Scheme {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<ScaleVariant6RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2SchemeVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant6Type {
    #[educe(Default)]
    #[serde(rename = "bin-ordinal")]
    BinOrdinal,
}
impl ToString for ScaleVariant6Type {
    fn to_string(&self) -> String {
        match *self {
            Self::BinOrdinal => "bin-ordinal".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant6Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "bin-ordinal" => Ok(Self::BinOrdinal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant6Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant6Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant7Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant7DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant7DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant7DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant7Nice {
    #[educe(Default)]
    Variant0(bool),
    Variant1(ScaleVariant7NiceVariant1),
    Variant2 {
        interval: ScaleVariant7NiceVariant2Interval,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        step: Option<NumberOrSignal>,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant7NiceVariant1 {
    #[educe(Default)]
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl ToString for ScaleVariant7NiceVariant1 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7NiceVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7NiceVariant1 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7NiceVariant1 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant7NiceVariant2Interval {
    #[educe(Default)]
    Variant0(ScaleVariant7NiceVariant2IntervalVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant7NiceVariant2IntervalVariant0 {
    #[educe(Default)]
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl ToString for ScaleVariant7NiceVariant2IntervalVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant7Range {
    #[educe(Default)]
    Variant0(ScaleVariant7RangeVariant0),
    Variant1(Vec<ScaleVariant7RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant7RangeVariant2Extent>,
        scheme: ScaleVariant7RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant7RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant7RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2Extent {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2Scheme {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<ScaleVariant7RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2SchemeVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant7Type {
    #[educe(Default)]
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ToString for ScaleVariant7Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant8Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant8DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant8DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant8DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant8Nice {
    #[educe(Default)]
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant8Range {
    #[educe(Default)]
    Variant0(ScaleVariant8RangeVariant0),
    Variant1(Vec<ScaleVariant8RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant8RangeVariant2Extent>,
        scheme: ScaleVariant8RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant8RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant8RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant8RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant8RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant8RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2Extent {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2Scheme {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<ScaleVariant8RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2SchemeVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant8Type {
    #[educe(Default)]
    #[serde(rename = "linear")]
    Linear,
    #[serde(rename = "sqrt")]
    Sqrt,
    #[serde(rename = "sequential")]
    Sequential,
}
impl ToString for ScaleVariant8Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Linear => "linear".to_string(),
            Self::Sqrt => "sqrt".to_string(),
            Self::Sequential => "sequential".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant8Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "linear" => Ok(Self::Linear),
            "sqrt" => Ok(Self::Sqrt),
            "sequential" => Ok(Self::Sequential),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant8Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant8Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant9Domain {
    #[educe(Default)]
    Variant0(Vec<ScaleVariant9DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant9DomainRaw {
    #[educe(Default)]
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant9DomainVariant0Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant9Nice {
    #[educe(Default)]
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant9Range {
    #[educe(Default)]
    Variant0(ScaleVariant9RangeVariant0),
    Variant1(Vec<ScaleVariant9RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant9RangeVariant2Extent>,
        scheme: ScaleVariant9RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant9RangeVariant0 {
    #[educe(Default)]
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ToString for ScaleVariant9RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant9RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant9RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant9RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant1Item {
    #[educe(Default)]
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2Extent {
    #[educe(Default)]
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2Scheme {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<ScaleVariant9RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2SchemeVariant1Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum ScaleVariant9Type {
    #[educe(Default)]
    #[serde(rename = "log")]
    Log,
}
impl ToString for ScaleVariant9Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Log => "log".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant9Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "log" => Ok(Self::Log),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant9Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant9Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Scope {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub axes: Vec<Axis>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub data: Vec<Data>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub layout: Option<Layout>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub legends: Vec<Legend>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub marks: Vec<ScopeMarksItem>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub projections: Vec<Projection>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub scales: Vec<Scale>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub signals: Vec<Signal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<Title>,
    #[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub usermeta: std::collections::HashMap<String, serde_json::Value>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum ScopeMarksItem {
    #[educe(Default)]
    Group(MarkGroup),
    Visual(MarkVisual),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Selector(pub String);
impl std::ops::Deref for Selector {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SequenceTransform {
    #[serde(rename = "as", default = "defaults::sequence_transform_as")]
    pub as_: SequenceTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub start: SequenceTransformStart,
    #[serde(default = "defaults::sequence_transform_step")]
    pub step: SequenceTransformStep,
    pub stop: SequenceTransformStop,
    #[serde(rename = "type")]
    pub type_: SequenceTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum SequenceTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum SequenceTransformStart {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum SequenceTransformStep {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum SequenceTransformStop {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SequenceTransformType {
    #[educe(Default)]
    #[serde(rename = "sequence")]
    Sequence,
}
impl ToString for SequenceTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Sequence => "sequence".to_string(),
        }
    }
}
impl std::str::FromStr for SequenceTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "sequence" => Ok(Self::Sequence),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SequenceTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SequenceTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Signal {
    #[educe(Default)]
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        name: SignalName,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnEvents>,
        push: SignalVariant0Push,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bind: Option<Bind>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        name: SignalName,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnEvents>,
        #[serde(default = "defaults::default_bool::<true>")]
        react: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        update: Option<ExprString>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        value: Option<serde_json::Value>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bind: Option<Bind>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        init: ExprString,
        name: SignalName,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnEvents>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        value: Option<serde_json::Value>,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct SignalName(String);
impl std::ops::Deref for SignalName {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl std::convert::TryFrom<String> for SignalName {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        if [
            "parent".to_string(),
            "datum".to_string(),
            "event".to_string(),
            "item".to_string(),
        ]
        .contains(&value)
        {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct SignalRef {
    pub signal: String,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SignalVariant0Push {
    #[educe(Default)]
    #[serde(rename = "outer")]
    Outer,
}
impl ToString for SignalVariant0Push {
    fn to_string(&self) -> String {
        match *self {
            Self::Outer => "outer".to_string(),
        }
    }
}
impl std::str::FromStr for SignalVariant0Push {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "outer" => Ok(Self::Outer),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SignalVariant0Push {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SignalVariant0Push {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum SortOrder {
    #[educe(Default)]
    Variant0(SortOrderVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum SortOrderVariant0 {
    #[educe(Default)]
    #[serde(rename = "ascending")]
    Ascending,
    #[serde(rename = "descending")]
    Descending,
}
impl ToString for SortOrderVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Ascending => "ascending".to_string(),
            Self::Descending => "descending".to_string(),
        }
    }
}
impl std::str::FromStr for SortOrderVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "ascending" => Ok(Self::Ascending),
            "descending" => Ok(Self::Descending),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SortOrderVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SortOrderVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StackTransform {
    #[serde(rename = "as", default = "defaults::stack_transform_as")]
    pub as_: StackTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<StackTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<StackTransformGroupby>,
    #[serde(default = "defaults::stack_transform_offset")]
    pub offset: StackTransformOffset,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: StackTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StackTransformAs {
    #[educe(Default)]
    Variant0(StackTransformAsVariant0, StackTransformAsVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StackTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StackTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StackTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<StackTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StackTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StackTransformOffset {
    #[educe(Default)]
    Variant0(StackTransformOffsetVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StackTransformOffsetVariant0 {
    #[educe(Default)]
    #[serde(rename = "zero")]
    Zero,
    #[serde(rename = "center")]
    Center,
    #[serde(rename = "normalize")]
    Normalize,
}
impl ToString for StackTransformOffsetVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Zero => "zero".to_string(),
            Self::Center => "center".to_string(),
            Self::Normalize => "normalize".to_string(),
        }
    }
}
impl std::str::FromStr for StackTransformOffsetVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "zero" => Ok(Self::Zero),
            "center" => Ok(Self::Center),
            "normalize" => Ok(Self::Normalize),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StackTransformOffsetVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StackTransformOffsetVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StackTransformType {
    #[educe(Default)]
    #[serde(rename = "stack")]
    Stack,
}
impl ToString for StackTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Stack => "stack".to_string(),
        }
    }
}
impl std::str::FromStr for StackTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "stack" => Ok(Self::Stack),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StackTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StackTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StratifyTransform {
    pub key: StratifyTransformKey,
    #[serde(rename = "parentKey")]
    pub parent_key: StratifyTransformParentKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: StratifyTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StratifyTransformKey {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StratifyTransformParentKey {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StratifyTransformType {
    #[educe(Default)]
    #[serde(rename = "stratify")]
    Stratify,
}
impl ToString for StratifyTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Stratify => "stratify".to_string(),
        }
    }
}
impl std::str::FromStr for StratifyTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "stratify" => Ok(Self::Stratify),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StratifyTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StratifyTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct Stream {
    #[serde(flatten)]
    pub subtype_0: StreamSubtype0,
    #[serde(flatten)]
    pub subtype_1: StreamSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StreamSubtype0 {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub between: Vec<Stream>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consume: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debounce: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<StreamSubtype0Filter>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub markname: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub marktype: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throttle: Option<f64>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StreamSubtype0Filter {
    #[educe(Default)]
    Variant0(ExprString),
    Variant1(Vec<ExprString>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StreamSubtype1 {
    #[educe(Default)]
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        source: Option<String>,
        #[serde(rename = "type")]
        type_: String,
    },
    Variant1 {
        stream: Stream,
    },
    Variant2 {
        merge: Vec<Stream>,
    },
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringModifiers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<Field>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StringOrSignal {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StringValue {
    #[educe(Default)]
    Variant0(Vec<StringValueVariant0Item>),
    Variant1(StringValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: StringValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StringValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StringValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StringValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StringValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StringValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StringValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: String,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StringValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StringValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StringValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StringValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StringValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StringValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: String,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StringValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StringValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StringValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeCapValue {
    #[educe(Default)]
    Variant0(Vec<StrokeCapValueVariant0Item>),
    Variant1(StrokeCapValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: StrokeCapValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StrokeCapValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StrokeCapValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StrokeCapValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StrokeCapValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "butt")]
    Butt,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "square")]
    Square,
}
impl ToString for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Butt => "butt".to_string(),
            Self::Round => "round".to_string(),
            Self::Square => "square".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "butt" => Ok(Self::Butt),
            "round" => Ok(Self::Round),
            "square" => Ok(Self::Square),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StrokeCapValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StrokeCapValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StrokeCapValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StrokeCapValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StrokeCapValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeCapValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: StrokeCapValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StrokeCapValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "butt")]
    Butt,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "square")]
    Square,
}
impl ToString for StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Butt => "butt".to_string(),
            Self::Round => "round".to_string(),
            Self::Square => "square".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "butt" => Ok(Self::Butt),
            "round" => Ok(Self::Round),
            "square" => Ok(Self::Square),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeCapValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeJoinValue {
    #[educe(Default)]
    Variant0(Vec<StrokeJoinValueVariant0Item>),
    Variant1(StrokeJoinValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: StrokeJoinValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StrokeJoinValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "miter")]
    Miter,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "bevel")]
    Bevel,
}
impl ToString for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Miter => "miter".to_string(),
            Self::Round => "round".to_string(),
            Self::Bevel => "bevel".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "miter" => Ok(Self::Miter),
            "round" => Ok(Self::Round),
            "bevel" => Ok(Self::Bevel),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StrokeJoinValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StrokeJoinValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StrokeJoinValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StrokeJoinValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StrokeJoinValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: StrokeJoinValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StrokeJoinValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    #[serde(rename = "miter")]
    Miter,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "bevel")]
    Bevel,
}
impl ToString for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Miter => "miter".to_string(),
            Self::Round => "round".to_string(),
            Self::Bevel => "bevel".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "miter" => Ok(Self::Miter),
            "round" => Ok(Self::Round),
            "bevel" => Ok(Self::Bevel),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Style {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<String>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TextOrSignal {
    #[educe(Default)]
    Variant0(TextOrSignalVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TextOrSignalVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<String>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TextValue {
    #[educe(Default)]
    Variant0(Vec<TextValueVariant0Item>),
    Variant1(TextValueVariant1),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: TextValueVariant0ItemSubtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: TextValueVariant0ItemSubtype1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<TextValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<TextValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<TextValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<TextValueVariant0ItemSubtype1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TextValueVariant0ItemSubtype1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: TextValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TextValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<String>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1Subtype1Subtype3 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: TextValueVariant1Subtype1,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<TextValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<TextValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<TextValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<TextValueVariant1Subtype1Subtype3>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TextValueVariant1Subtype1Subtype0 {
    #[educe(Default)]
    Variant0(SignalRef),
    Variant1 {
        value: TextValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: TextValueVariant1Subtype1Subtype0Variant3Range,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TextValueVariant1Subtype1Subtype0Variant1Value {
    #[educe(Default)]
    Variant0(String),
    Variant1(Vec<String>),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TextValueVariant1Subtype1Subtype0Variant3Range {
    #[educe(Default)]
    Variant0(f64),
    Variant1(bool),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant1Subtype1Subtype1 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant1Subtype1Subtype2 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TextValueVariant1Subtype1Subtype3 {}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TickBand {
    #[educe(Default)]
    Variant0(TickBandVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TickBandVariant0 {
    #[educe(Default)]
    #[serde(rename = "center")]
    Center,
    #[serde(rename = "extent")]
    Extent,
}
impl ToString for TickBandVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Center => "center".to_string(),
            Self::Extent => "extent".to_string(),
        }
    }
}
impl std::str::FromStr for TickBandVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "center" => Ok(Self::Center),
            "extent" => Ok(Self::Extent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TickBandVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TickBandVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum TickCount {
    #[educe(Default)]
    Variant0(f64),
    Variant1(TickCountVariant1),
    Variant2 {
        interval: TickCountVariant2Interval,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        step: Option<NumberOrSignal>,
    },
    Variant3(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TickCountVariant1 {
    #[educe(Default)]
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl ToString for TickCountVariant1 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for TickCountVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TickCountVariant1 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TickCountVariant1 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TickCountVariant2Interval {
    #[educe(Default)]
    Variant0(TickCountVariant2IntervalVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TickCountVariant2IntervalVariant0 {
    #[educe(Default)]
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl ToString for TickCountVariant2IntervalVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for TickCountVariant2IntervalVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TickCountVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TickCountVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TimeunitTransform {
    #[serde(rename = "as", default = "defaults::timeunit_transform_as")]
    pub as_: TimeunitTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<TimeunitTransformExtent>,
    pub field: TimeunitTransformField,
    #[serde(default = "defaults::timeunit_transform_interval")]
    pub interval: TimeunitTransformInterval,
    #[serde(default = "defaults::timeunit_transform_maxbins")]
    pub maxbins: TimeunitTransformMaxbins,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::timeunit_transform_step")]
    pub step: TimeunitTransformStep,
    #[serde(default = "defaults::timeunit_transform_timezone")]
    pub timezone: TimeunitTransformTimezone,
    #[serde(rename = "type")]
    pub type_: TimeunitTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<TimeunitTransformUnits>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformAs {
    #[educe(Default)]
    Variant0(TimeunitTransformAsVariant0, TimeunitTransformAsVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformExtent {
    #[educe(Default)]
    Variant0(Vec<TimeunitTransformExtentVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformExtentVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformInterval {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformMaxbins {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformStep {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformTimezone {
    #[educe(Default)]
    Variant0(TimeunitTransformTimezoneVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TimeunitTransformTimezoneVariant0 {
    #[educe(Default)]
    #[serde(rename = "local")]
    Local,
    #[serde(rename = "utc")]
    Utc,
}
impl ToString for TimeunitTransformTimezoneVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Local => "local".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for TimeunitTransformTimezoneVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "local" => Ok(Self::Local),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TimeunitTransformTimezoneVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TimeunitTransformTimezoneVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TimeunitTransformType {
    #[educe(Default)]
    #[serde(rename = "timeunit")]
    Timeunit,
}
impl ToString for TimeunitTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Timeunit => "timeunit".to_string(),
        }
    }
}
impl std::str::FromStr for TimeunitTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "timeunit" => Ok(Self::Timeunit),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TimeunitTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TimeunitTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformUnits {
    #[educe(Default)]
    Variant0(Vec<TimeunitTransformUnitsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TimeunitTransformUnitsVariant0Item {
    #[educe(Default)]
    Variant0(TimeunitTransformUnitsVariant0ItemVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TimeunitTransformUnitsVariant0ItemVariant0 {
    #[educe(Default)]
    #[serde(rename = "year")]
    Year,
    #[serde(rename = "quarter")]
    Quarter,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "dayofyear")]
    Dayofyear,
    #[serde(rename = "hours")]
    Hours,
    #[serde(rename = "minutes")]
    Minutes,
    #[serde(rename = "seconds")]
    Seconds,
    #[serde(rename = "milliseconds")]
    Milliseconds,
}
impl ToString for TimeunitTransformUnitsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Year => "year".to_string(),
            Self::Quarter => "quarter".to_string(),
            Self::Month => "month".to_string(),
            Self::Week => "week".to_string(),
            Self::Date => "date".to_string(),
            Self::Day => "day".to_string(),
            Self::Dayofyear => "dayofyear".to_string(),
            Self::Hours => "hours".to_string(),
            Self::Minutes => "minutes".to_string(),
            Self::Seconds => "seconds".to_string(),
            Self::Milliseconds => "milliseconds".to_string(),
        }
    }
}
impl std::str::FromStr for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "year" => Ok(Self::Year),
            "quarter" => Ok(Self::Quarter),
            "month" => Ok(Self::Month),
            "week" => Ok(Self::Week),
            "date" => Ok(Self::Date),
            "day" => Ok(Self::Day),
            "dayofyear" => Ok(Self::Dayofyear),
            "hours" => Ok(Self::Hours),
            "minutes" => Ok(Self::Minutes),
            "seconds" => Ok(Self::Seconds),
            "milliseconds" => Ok(Self::Milliseconds),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged, deny_unknown_fields)]
pub enum Title {
    #[educe(Default)]
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<TitleVariant1Align>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        anchor: Option<TitleVariant1Anchor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        angle: Option<TitleVariant1Angle>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        baseline: Option<TitleVariant1Baseline>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        color: Option<TitleVariant1Color>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        dx: Option<TitleVariant1Dx>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        dy: Option<TitleVariant1Dy>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<TitleVariant1Encode>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        font: Option<TitleVariant1Font>,
        #[serde(rename = "fontSize", default, skip_serializing_if = "Option::is_none")]
        font_size: Option<TitleVariant1FontSize>,
        #[serde(rename = "fontStyle", default, skip_serializing_if = "Option::is_none")]
        font_style: Option<TitleVariant1FontStyle>,
        #[serde(
            rename = "fontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        font_weight: Option<TitleVariant1FontWeight>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        frame: Option<TitleVariant1Frame>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interactive: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        limit: Option<TitleVariant1Limit>,
        #[serde(
            rename = "lineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        line_height: Option<TitleVariant1LineHeight>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<TitleVariant1Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<TitleVariant1Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        style: Option<Style>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        subtitle: Option<TextOrSignal>,
        #[serde(
            rename = "subtitleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_color: Option<TitleVariant1SubtitleColor>,
        #[serde(
            rename = "subtitleFont",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font: Option<TitleVariant1SubtitleFont>,
        #[serde(
            rename = "subtitleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font_size: Option<TitleVariant1SubtitleFontSize>,
        #[serde(
            rename = "subtitleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font_style: Option<TitleVariant1SubtitleFontStyle>,
        #[serde(
            rename = "subtitleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font_weight: Option<TitleVariant1SubtitleFontWeight>,
        #[serde(
            rename = "subtitleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_line_height: Option<TitleVariant1SubtitleLineHeight>,
        #[serde(
            rename = "subtitlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        text: Option<TextOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Align {
    #[educe(Default)]
    Variant0(TitleVariant1AlignVariant0),
    Variant1(AlignValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TitleVariant1AlignVariant0 {
    #[educe(Default)]
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ToString for TitleVariant1AlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1AlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1AlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1AlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Anchor {
    #[educe(Default)]
    Variant0(Option<TitleVariant1AnchorVariant0>),
    Variant1(AnchorValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TitleVariant1AnchorVariant0 {
    #[educe(Default)]
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ToString for TitleVariant1AnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1AnchorVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1AnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1AnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Angle {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Baseline {
    #[educe(Default)]
    Variant0(TitleVariant1BaselineVariant0),
    Variant1(BaselineValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TitleVariant1BaselineVariant0 {
    #[educe(Default)]
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ToString for TitleVariant1BaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1BaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1BaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1BaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Color {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Dx {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Dy {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct TitleVariant1Encode {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<TitleVariant1EncodeSubtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<TitleVariant1EncodeSubtype1>,
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TitleVariant1EncodeSubtype0 {}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TitleVariant1EncodeSubtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subtitle: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Font {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1FontSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1FontStyle {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1FontWeight {
    #[educe(Default)]
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Frame {
    #[educe(Default)]
    Variant0(TitleVariant1FrameVariant0),
    Variant1(StringValue),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TitleVariant1FrameVariant0 {
    #[educe(Default)]
    #[serde(rename = "group")]
    Group,
    #[serde(rename = "bounds")]
    Bounds,
}
impl ToString for TitleVariant1FrameVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Group => "group".to_string(),
            Self::Bounds => "bounds".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1FrameVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "group" => Ok(Self::Group),
            "bounds" => Ok(Self::Bounds),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1FrameVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1FrameVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Limit {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1LineHeight {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Offset {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1Orient {
    #[educe(Default)]
    Variant0(TitleVariant1OrientVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TitleVariant1OrientVariant0 {
    #[educe(Default)]
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ToString for TitleVariant1OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1OrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleColor {
    #[educe(Default)]
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFont {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontStyle {
    #[educe(Default)]
    Variant0(String),
    Variant1(StringValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontWeight {
    #[educe(Default)]
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleLineHeight {
    #[educe(Default)]
    Variant0(f64),
    Variant1(NumberValue),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum Transform {
    #[educe(Default)]
    CrossfilterTransform(CrossfilterTransform),
    ResolvefilterTransform(ResolvefilterTransform),
    LinkpathTransform(LinkpathTransform),
    PieTransform(PieTransform),
    StackTransform(StackTransform),
    ForceTransform(ForceTransform),
    ContourTransform(ContourTransform),
    GeojsonTransform(GeojsonTransform),
    GeopathTransform(GeopathTransform),
    GeopointTransform(GeopointTransform),
    GeoshapeTransform(GeoshapeTransform),
    GraticuleTransform(GraticuleTransform),
    HeatmapTransform(HeatmapTransform),
    IsocontourTransform(IsocontourTransform),
    Kde2dTransform(Kde2dTransform),
    NestTransform(NestTransform),
    PackTransform(PackTransform),
    PartitionTransform(PartitionTransform),
    StratifyTransform(StratifyTransform),
    TreeTransform(TreeTransform),
    TreelinksTransform(TreelinksTransform),
    TreemapTransform(TreemapTransform),
    LabelTransform(LabelTransform),
    LoessTransform(LoessTransform),
    RegressionTransform(RegressionTransform),
    AggregateTransform(AggregateTransform),
    BinTransform(BinTransform),
    CollectTransform(CollectTransform),
    CountpatternTransform(CountpatternTransform),
    CrossTransform(CrossTransform),
    DensityTransform(DensityTransform),
    DotbinTransform(DotbinTransform),
    ExtentTransform(ExtentTransform),
    FilterTransform(FilterTransform),
    FlattenTransform(FlattenTransform),
    FoldTransform(FoldTransform),
    FormulaTransform(FormulaTransform),
    ImputeTransform(ImputeTransform),
    JoinaggregateTransform(JoinaggregateTransform),
    KdeTransform(KdeTransform),
    LookupTransform(LookupTransform),
    PivotTransform(PivotTransform),
    ProjectTransform(ProjectTransform),
    QuantileTransform(QuantileTransform),
    SampleTransform(SampleTransform),
    SequenceTransform(SequenceTransform),
    TimeunitTransform(TimeunitTransform),
    WindowTransform(WindowTransform),
    IdentifierTransform(IdentifierTransform),
    VoronoiTransform(VoronoiTransform),
    WordcloudTransform(WordcloudTransform),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TransformMark {
    #[educe(Default)]
    CrossfilterTransform(CrossfilterTransform),
    ResolvefilterTransform(ResolvefilterTransform),
    LinkpathTransform(LinkpathTransform),
    PieTransform(PieTransform),
    StackTransform(StackTransform),
    ForceTransform(ForceTransform),
    GeojsonTransform(GeojsonTransform),
    GeopathTransform(GeopathTransform),
    GeopointTransform(GeopointTransform),
    GeoshapeTransform(GeoshapeTransform),
    HeatmapTransform(HeatmapTransform),
    PackTransform(PackTransform),
    PartitionTransform(PartitionTransform),
    StratifyTransform(StratifyTransform),
    TreeTransform(TreeTransform),
    TreemapTransform(TreemapTransform),
    LabelTransform(LabelTransform),
    BinTransform(BinTransform),
    CollectTransform(CollectTransform),
    DotbinTransform(DotbinTransform),
    ExtentTransform(ExtentTransform),
    FormulaTransform(FormulaTransform),
    JoinaggregateTransform(JoinaggregateTransform),
    LookupTransform(LookupTransform),
    SampleTransform(SampleTransform),
    TimeunitTransform(TimeunitTransform),
    WindowTransform(WindowTransform),
    IdentifierTransform(IdentifierTransform),
    VoronoiTransform(VoronoiTransform),
    WordcloudTransform(WordcloudTransform),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TreeTransform {
    #[serde(rename = "as", default = "defaults::tree_transform_as")]
    pub as_: TreeTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<TreeTransformField>,
    #[serde(default = "defaults::tree_transform_method")]
    pub method: TreeTransformMethod,
    #[serde(rename = "nodeSize", default, skip_serializing_if = "Option::is_none")]
    pub node_size: Option<TreeTransformNodeSize>,
    #[serde(default = "defaults::tree_transform_separation")]
    pub separation: TreeTransformSeparation,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<TreeTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: TreeTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreeTransformAs {
    #[educe(Default)]
    Variant0(
        TreeTransformAsVariant0,
        TreeTransformAsVariant0,
        TreeTransformAsVariant0,
        TreeTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreeTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreeTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreeTransformMethod {
    #[educe(Default)]
    Variant0(TreeTransformMethodVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TreeTransformMethodVariant0 {
    #[educe(Default)]
    #[serde(rename = "tidy")]
    Tidy,
    #[serde(rename = "cluster")]
    Cluster,
}
impl ToString for TreeTransformMethodVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Tidy => "tidy".to_string(),
            Self::Cluster => "cluster".to_string(),
        }
    }
}
impl std::str::FromStr for TreeTransformMethodVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tidy" => Ok(Self::Tidy),
            "cluster" => Ok(Self::Cluster),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreeTransformNodeSize {
    #[educe(Default)]
    Variant0(TreeTransformNodeSizeVariant0, TreeTransformNodeSizeVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreeTransformNodeSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreeTransformSeparation {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreeTransformSize {
    #[educe(Default)]
    Variant0(TreeTransformSizeVariant0, TreeTransformSizeVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreeTransformSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TreeTransformType {
    #[educe(Default)]
    #[serde(rename = "tree")]
    Tree,
}
impl ToString for TreeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Tree => "tree".to_string(),
        }
    }
}
impl std::str::FromStr for TreeTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tree" => Ok(Self::Tree),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreeTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreeTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TreelinksTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: TreelinksTransformType,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TreelinksTransformType {
    #[educe(Default)]
    #[serde(rename = "treelinks")]
    Treelinks,
}
impl ToString for TreelinksTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Treelinks => "treelinks".to_string(),
        }
    }
}
impl std::str::FromStr for TreelinksTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "treelinks" => Ok(Self::Treelinks),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreelinksTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreelinksTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TreemapTransform {
    #[serde(rename = "as", default = "defaults::treemap_transform_as")]
    pub as_: TreemapTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<TreemapTransformField>,
    #[serde(default = "defaults::treemap_transform_method")]
    pub method: TreemapTransformMethod,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<TreemapTransformPadding>,
    #[serde(
        rename = "paddingBottom",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_bottom: Option<TreemapTransformPaddingBottom>,
    #[serde(
        rename = "paddingInner",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_inner: Option<TreemapTransformPaddingInner>,
    #[serde(
        rename = "paddingLeft",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_left: Option<TreemapTransformPaddingLeft>,
    #[serde(
        rename = "paddingOuter",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_outer: Option<TreemapTransformPaddingOuter>,
    #[serde(
        rename = "paddingRight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_right: Option<TreemapTransformPaddingRight>,
    #[serde(
        rename = "paddingTop",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_top: Option<TreemapTransformPaddingTop>,
    #[serde(default = "defaults::treemap_transform_ratio")]
    pub ratio: TreemapTransformRatio,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub round: Option<TreemapTransformRound>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<TreemapTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: TreemapTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformAs {
    #[educe(Default)]
    Variant0(
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformField {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformMethod {
    #[educe(Default)]
    Variant0(TreemapTransformMethodVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TreemapTransformMethodVariant0 {
    #[educe(Default)]
    #[serde(rename = "squarify")]
    Squarify,
    #[serde(rename = "resquarify")]
    Resquarify,
    #[serde(rename = "binary")]
    Binary,
    #[serde(rename = "dice")]
    Dice,
    #[serde(rename = "slice")]
    Slice,
    #[serde(rename = "slicedice")]
    Slicedice,
}
impl ToString for TreemapTransformMethodVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Squarify => "squarify".to_string(),
            Self::Resquarify => "resquarify".to_string(),
            Self::Binary => "binary".to_string(),
            Self::Dice => "dice".to_string(),
            Self::Slice => "slice".to_string(),
            Self::Slicedice => "slicedice".to_string(),
        }
    }
}
impl std::str::FromStr for TreemapTransformMethodVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "squarify" => Ok(Self::Squarify),
            "resquarify" => Ok(Self::Resquarify),
            "binary" => Ok(Self::Binary),
            "dice" => Ok(Self::Dice),
            "slice" => Ok(Self::Slice),
            "slicedice" => Ok(Self::Slicedice),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreemapTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreemapTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformPadding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformPaddingBottom {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformPaddingInner {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformPaddingLeft {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformPaddingOuter {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformPaddingRight {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformPaddingTop {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformRatio {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformRound {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformSize {
    #[educe(Default)]
    Variant0(TreemapTransformSizeVariant0, TreemapTransformSizeVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum TreemapTransformSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum TreemapTransformType {
    #[educe(Default)]
    #[serde(rename = "treemap")]
    Treemap,
}
impl ToString for TreemapTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Treemap => "treemap".to_string(),
        }
    }
}
impl std::str::FromStr for TreemapTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "treemap" => Ok(Self::Treemap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreemapTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreemapTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VoronoiTransform {
    #[serde(rename = "as", default = "defaults::voronoi_transform_as")]
    pub as_: VoronoiTransformAs,
    #[serde(default = "defaults::voronoi_transform_extent")]
    pub extent: VoronoiTransformExtent,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<VoronoiTransformSize>,
    #[serde(rename = "type")]
    pub type_: VoronoiTransformType,
    pub x: VoronoiTransformX,
    pub y: VoronoiTransformY,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum VoronoiTransformAs {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum VoronoiTransformExtent {
    #[educe(Default)]
    Variant0(serde_json::Value, serde_json::Value),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum VoronoiTransformSize {
    #[educe(Default)]
    Variant0(VoronoiTransformSizeVariant0, VoronoiTransformSizeVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum VoronoiTransformSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum VoronoiTransformType {
    #[educe(Default)]
    #[serde(rename = "voronoi")]
    Voronoi,
}
impl ToString for VoronoiTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Voronoi => "voronoi".to_string(),
        }
    }
}
impl std::str::FromStr for VoronoiTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "voronoi" => Ok(Self::Voronoi),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for VoronoiTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for VoronoiTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum VoronoiTransformX {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum VoronoiTransformY {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WindowTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<WindowTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<WindowTransformFields>,
    #[serde(default = "defaults::window_transform_frame")]
    pub frame: WindowTransformFrame,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<WindowTransformGroupby>,
    #[serde(
        rename = "ignorePeers",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub ignore_peers: Option<WindowTransformIgnorePeers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ops: Option<WindowTransformOps>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<WindowTransformParams>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: WindowTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformAs {
    #[educe(Default)]
    Variant0(Vec<WindowTransformAsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformAsVariant0Item {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformFields {
    #[educe(Default)]
    Variant0(Vec<WindowTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformFieldsVariant0Item {
    #[educe(Default)]
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformFrame {
    #[educe(Default)]
    Variant0(WindowTransformFrameVariant0, WindowTransformFrameVariant0),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformFrameVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformGroupby {
    #[educe(Default)]
    Variant0(Vec<WindowTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformGroupbyVariant0Item {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformIgnorePeers {
    #[educe(Default)]
    Variant0(bool),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformOps {
    #[educe(Default)]
    Variant0(Vec<WindowTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformOpsVariant0Item {
    #[educe(Default)]
    Variant0(WindowTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WindowTransformOpsVariant0ItemVariant0 {
    #[educe(Default)]
    #[serde(rename = "row_number")]
    RowNumber,
    #[serde(rename = "rank")]
    Rank,
    #[serde(rename = "dense_rank")]
    DenseRank,
    #[serde(rename = "percent_rank")]
    PercentRank,
    #[serde(rename = "cume_dist")]
    CumeDist,
    #[serde(rename = "ntile")]
    Ntile,
    #[serde(rename = "lag")]
    Lag,
    #[serde(rename = "lead")]
    Lead,
    #[serde(rename = "first_value")]
    FirstValue,
    #[serde(rename = "last_value")]
    LastValue,
    #[serde(rename = "nth_value")]
    NthValue,
    #[serde(rename = "prev_value")]
    PrevValue,
    #[serde(rename = "next_value")]
    NextValue,
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl ToString for WindowTransformOpsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::RowNumber => "row_number".to_string(),
            Self::Rank => "rank".to_string(),
            Self::DenseRank => "dense_rank".to_string(),
            Self::PercentRank => "percent_rank".to_string(),
            Self::CumeDist => "cume_dist".to_string(),
            Self::Ntile => "ntile".to_string(),
            Self::Lag => "lag".to_string(),
            Self::Lead => "lead".to_string(),
            Self::FirstValue => "first_value".to_string(),
            Self::LastValue => "last_value".to_string(),
            Self::NthValue => "nth_value".to_string(),
            Self::PrevValue => "prev_value".to_string(),
            Self::NextValue => "next_value".to_string(),
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for WindowTransformOpsVariant0ItemVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "row_number" => Ok(Self::RowNumber),
            "rank" => Ok(Self::Rank),
            "dense_rank" => Ok(Self::DenseRank),
            "percent_rank" => Ok(Self::PercentRank),
            "cume_dist" => Ok(Self::CumeDist),
            "ntile" => Ok(Self::Ntile),
            "lag" => Ok(Self::Lag),
            "lead" => Ok(Self::Lead),
            "first_value" => Ok(Self::FirstValue),
            "last_value" => Ok(Self::LastValue),
            "nth_value" => Ok(Self::NthValue),
            "prev_value" => Ok(Self::PrevValue),
            "next_value" => Ok(Self::NextValue),
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformParams {
    #[educe(Default)]
    Variant0(Vec<WindowTransformParamsVariant0Item>),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WindowTransformParamsVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WindowTransformType {
    #[educe(Default)]
    #[serde(rename = "window")]
    Window,
}
impl ToString for WindowTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Window => "window".to_string(),
        }
    }
}
impl std::str::FromStr for WindowTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "window" => Ok(Self::Window),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WindowTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WindowTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WordcloudTransform {
    #[serde(rename = "as", default = "defaults::wordcloud_transform_as")]
    pub as_: WordcloudTransformAs,
    #[serde(default = "defaults::wordcloud_transform_font")]
    pub font: WordcloudTransformFont,
    #[serde(
        rename = "fontSize",
        default = "defaults::wordcloud_transform_font_size"
    )]
    pub font_size: WordcloudTransformFontSize,
    #[serde(
        rename = "fontSizeRange",
        default = "defaults::wordcloud_transform_font_size_range"
    )]
    pub font_size_range: WordcloudTransformFontSizeRange,
    #[serde(
        rename = "fontStyle",
        default = "defaults::wordcloud_transform_font_style"
    )]
    pub font_style: WordcloudTransformFontStyle,
    #[serde(
        rename = "fontWeight",
        default = "defaults::wordcloud_transform_font_weight"
    )]
    pub font_weight: WordcloudTransformFontWeight,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<WordcloudTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotate: Option<WordcloudTransformRotate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<WordcloudTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spiral: Option<WordcloudTransformSpiral>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<WordcloudTransformText>,
    #[serde(rename = "type")]
    pub type_: WordcloudTransformType,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformAs {
    #[educe(Default)]
    Variant0(
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformAsVariant0 {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformFont {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformFontSize {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformFontSizeRange {
    #[educe(Default)]
    Variant0(Vec<WordcloudTransformFontSizeRangeVariant0Item>),
    Variant1(SignalRef),
    Variant2,
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformFontSizeRangeVariant0Item {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformFontStyle {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformFontWeight {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformPadding {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformRotate {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformSize {
    #[educe(Default)]
    Variant0(
        WordcloudTransformSizeVariant0,
        WordcloudTransformSizeVariant0,
    ),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformSizeVariant0 {
    #[educe(Default)]
    Variant0(f64),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformSpiral {
    #[educe(Default)]
    Variant0(String),
    Variant1(SignalRef),
}
#[derive(Clone, Debug, Deserialize, Serialize, educe :: Educe)]
#[educe(Default)]
#[serde(untagged)]
pub enum WordcloudTransformText {
    #[educe(Default)]
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
#[derive(
    Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, educe :: Educe,
)]
#[educe(Default)]
pub enum WordcloudTransformType {
    #[educe(Default)]
    #[serde(rename = "wordcloud")]
    Wordcloud,
}
impl ToString for WordcloudTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Wordcloud => "wordcloud".to_string(),
        }
    }
}
impl std::str::FromStr for WordcloudTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "wordcloud" => Ok(Self::Wordcloud),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WordcloudTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WordcloudTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
    pub(super) fn default_i64<T, const V: i64>() -> T
    where
        T: std::convert::TryFrom<i64>,
        <T as std::convert::TryFrom<i64>>::Error: std::fmt::Debug,
    {
        T::try_from(V).unwrap()
    }
    pub(super) fn aggregate_transform_drop() -> super::AggregateTransformDrop {
        super::AggregateTransformDrop::Variant0(true)
    }
    pub(super) fn bin_transform_as() -> super::BinTransformAs {
        super::BinTransformAs::Variant0(
            super::BinTransformAsVariant0::Variant0("bin0".to_string()),
            super::BinTransformAsVariant0::Variant0("bin1".to_string()),
        )
    }
    pub(super) fn bin_transform_base() -> super::BinTransformBase {
        super::BinTransformBase::Variant0(10_f64)
    }
    pub(super) fn bin_transform_divide() -> super::BinTransformDivide {
        super::BinTransformDivide::Variant0(vec![
            super::BinTransformDivideVariant0Item::Variant0(5_f64),
            super::BinTransformDivideVariant0Item::Variant0(2_f64),
        ])
    }
    pub(super) fn bin_transform_interval() -> super::BinTransformInterval {
        super::BinTransformInterval::Variant0(true)
    }
    pub(super) fn bin_transform_maxbins() -> super::BinTransformMaxbins {
        super::BinTransformMaxbins::Variant0(20_f64)
    }
    pub(super) fn bin_transform_nice() -> super::BinTransformNice {
        super::BinTransformNice::Variant0(true)
    }
    pub(super) fn contour_transform_smooth() -> super::ContourTransformSmooth {
        super::ContourTransformSmooth::Variant0(true)
    }
    pub(super) fn countpattern_transform_as() -> super::CountpatternTransformAs {
        super::CountpatternTransformAs::Variant0(
            super::CountpatternTransformAsVariant0::Variant0("text".to_string()),
            super::CountpatternTransformAsVariant0::Variant0("count".to_string()),
        )
    }
    pub(super) fn countpattern_transform_case() -> super::CountpatternTransformCase {
        super::CountpatternTransformCase::Variant0(super::CountpatternTransformCaseVariant0::Mixed)
    }
    pub(super) fn countpattern_transform_pattern() -> super::CountpatternTransformPattern {
        super::CountpatternTransformPattern::Variant0("[\\w\"]+".to_string())
    }
    pub(super) fn cross_transform_as() -> super::CrossTransformAs {
        super::CrossTransformAs::Variant0(
            super::CrossTransformAsVariant0::Variant0("a".to_string()),
            super::CrossTransformAsVariant0::Variant0("b".to_string()),
        )
    }
    pub(super) fn density_transform_as() -> super::DensityTransformAs {
        super::DensityTransformAs::Variant0(vec![
            super::DensityTransformAsVariant0Item::Variant0("value".to_string()),
            super::DensityTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
    pub(super) fn density_transform_maxsteps() -> super::DensityTransformMaxsteps {
        super::DensityTransformMaxsteps::Variant0(200_f64)
    }
    pub(super) fn density_transform_method() -> super::DensityTransformMethod {
        super::DensityTransformMethod::Variant0("pdf".to_string())
    }
    pub(super) fn density_transform_minsteps() -> super::DensityTransformMinsteps {
        super::DensityTransformMinsteps::Variant0(25_f64)
    }
    pub(super) fn density_transform_distribution_variant0_stdev(
    ) -> super::DensityTransformDistributionVariant0Stdev {
        super::DensityTransformDistributionVariant0Stdev::Variant0(1_f64)
    }
    pub(super) fn density_transform_distribution_variant1_stdev(
    ) -> super::DensityTransformDistributionVariant1Stdev {
        super::DensityTransformDistributionVariant1Stdev::Variant0(1_f64)
    }
    pub(super) fn density_transform_distribution_variant2_max(
    ) -> super::DensityTransformDistributionVariant2Max {
        super::DensityTransformDistributionVariant2Max::Variant0(1_f64)
    }
    pub(super) fn dotbin_transform_as() -> super::DotbinTransformAs {
        super::DotbinTransformAs::Variant0("bin".to_string())
    }
    pub(super) fn fold_transform_as() -> super::FoldTransformAs {
        super::FoldTransformAs::Variant0(
            super::FoldTransformAsVariant0::Variant0("key".to_string()),
            super::FoldTransformAsVariant0::Variant0("value".to_string()),
        )
    }
    pub(super) fn force_transform_alpha() -> super::ForceTransformAlpha {
        super::ForceTransformAlpha::Variant0(1_f64)
    }
    pub(super) fn force_transform_alpha_min() -> super::ForceTransformAlphaMin {
        super::ForceTransformAlphaMin::Variant0(0.001_f64)
    }
    pub(super) fn force_transform_as() -> super::ForceTransformAs {
        super::ForceTransformAs::Variant0(vec![
            super::ForceTransformAsVariant0Item::Variant0("x".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("y".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("vx".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("vy".to_string()),
        ])
    }
    pub(super) fn force_transform_iterations() -> super::ForceTransformIterations {
        super::ForceTransformIterations::Variant0(300_f64)
    }
    pub(super) fn force_transform_velocity_decay() -> super::ForceTransformVelocityDecay {
        super::ForceTransformVelocityDecay::Variant0(0.4_f64)
    }
    pub(super) fn force_transform_forces_item_variant1_iterations(
    ) -> super::ForceTransformForcesItemVariant1Iterations {
        super::ForceTransformForcesItemVariant1Iterations::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_variant1_strength(
    ) -> super::ForceTransformForcesItemVariant1Strength {
        super::ForceTransformForcesItemVariant1Strength::Variant0(0.7_f64)
    }
    pub(super) fn force_transform_forces_item_variant2_distance_min(
    ) -> super::ForceTransformForcesItemVariant2DistanceMin {
        super::ForceTransformForcesItemVariant2DistanceMin::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_variant2_strength(
    ) -> super::ForceTransformForcesItemVariant2Strength {
        super::ForceTransformForcesItemVariant2Strength::Variant0(-30_f64)
    }
    pub(super) fn force_transform_forces_item_variant2_theta(
    ) -> super::ForceTransformForcesItemVariant2Theta {
        super::ForceTransformForcesItemVariant2Theta::Variant0(0.9_f64)
    }
    pub(super) fn force_transform_forces_item_variant3_distance(
    ) -> super::ForceTransformForcesItemVariant3Distance {
        super::ForceTransformForcesItemVariant3Distance::Variant0(30_f64)
    }
    pub(super) fn force_transform_forces_item_variant3_iterations(
    ) -> super::ForceTransformForcesItemVariant3Iterations {
        super::ForceTransformForcesItemVariant3Iterations::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_variant4_strength(
    ) -> super::ForceTransformForcesItemVariant4Strength {
        super::ForceTransformForcesItemVariant4Strength::Variant0(0.1_f64)
    }
    pub(super) fn force_transform_forces_item_variant5_strength(
    ) -> super::ForceTransformForcesItemVariant5Strength {
        super::ForceTransformForcesItemVariant5Strength::Variant0(0.1_f64)
    }
    pub(super) fn geopath_transform_as() -> super::GeopathTransformAs {
        super::GeopathTransformAs::Variant0("path".to_string())
    }
    pub(super) fn geopoint_transform_as() -> super::GeopointTransformAs {
        super::GeopointTransformAs::Variant0(
            super::GeopointTransformAsVariant0::Variant0("x".to_string()),
            super::GeopointTransformAsVariant0::Variant0("y".to_string()),
        )
    }
    pub(super) fn geoshape_transform_as() -> super::GeoshapeTransformAs {
        super::GeoshapeTransformAs::Variant0("shape".to_string())
    }
    pub(super) fn geoshape_transform_field() -> super::GeoshapeTransformField {
        super::GeoshapeTransformField::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("datum".to_string()),
        ))
    }
    pub(super) fn graticule_transform_precision() -> super::GraticuleTransformPrecision {
        super::GraticuleTransformPrecision::Variant0(2.5_f64)
    }
    pub(super) fn graticule_transform_step_major() -> super::GraticuleTransformStepMajor {
        super::GraticuleTransformStepMajor::Variant0(
            super::GraticuleTransformStepMajorVariant0::Variant0(90_f64),
            super::GraticuleTransformStepMajorVariant0::Variant0(360_f64),
        )
    }
    pub(super) fn graticule_transform_step_minor() -> super::GraticuleTransformStepMinor {
        super::GraticuleTransformStepMinor::Variant0(
            super::GraticuleTransformStepMinorVariant0::Variant0(10_f64),
            super::GraticuleTransformStepMinorVariant0::Variant0(10_f64),
        )
    }
    pub(super) fn heatmap_transform_as() -> super::HeatmapTransformAs {
        super::HeatmapTransformAs::Variant0("image".to_string())
    }
    pub(super) fn heatmap_transform_resolve() -> super::HeatmapTransformResolve {
        super::HeatmapTransformResolve::Variant0(
            super::HeatmapTransformResolveVariant0::Independent,
        )
    }
    pub(super) fn impute_transform_method() -> super::ImputeTransformMethod {
        super::ImputeTransformMethod::Variant0(super::ImputeTransformMethodVariant0::Value)
    }
    pub(super) fn isocontour_transform_as() -> super::IsocontourTransformAs {
        super::IsocontourTransformAs::Variant0("contour".to_string())
    }
    pub(super) fn isocontour_transform_resolve() -> super::IsocontourTransformResolve {
        super::IsocontourTransformResolve::Variant0(
            super::IsocontourTransformResolveVariant0::Independent,
        )
    }
    pub(super) fn isocontour_transform_smooth() -> super::IsocontourTransformSmooth {
        super::IsocontourTransformSmooth::Variant0(true)
    }
    pub(super) fn isocontour_transform_zero() -> super::IsocontourTransformZero {
        super::IsocontourTransformZero::Variant0(true)
    }
    pub(super) fn kde2d_transform_as() -> super::Kde2dTransformAs {
        super::Kde2dTransformAs::Variant0("grid".to_string())
    }
    pub(super) fn kde_transform_as() -> super::KdeTransformAs {
        super::KdeTransformAs::Variant0(vec![
            super::KdeTransformAsVariant0Item::Variant0("value".to_string()),
            super::KdeTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
    pub(super) fn kde_transform_maxsteps() -> super::KdeTransformMaxsteps {
        super::KdeTransformMaxsteps::Variant0(200_f64)
    }
    pub(super) fn kde_transform_minsteps() -> super::KdeTransformMinsteps {
        super::KdeTransformMinsteps::Variant0(25_f64)
    }
    pub(super) fn kde_transform_resolve() -> super::KdeTransformResolve {
        super::KdeTransformResolve::Variant0(super::KdeTransformResolveVariant0::Independent)
    }
    pub(super) fn label_transform_anchor() -> super::LabelTransformAnchor {
        super::LabelTransformAnchor::Variant0(vec![
            super::LabelTransformAnchorVariant0Item::Variant0("top-left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom-left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("top".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("top-right".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("right".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom-right".to_string()),
        ])
    }
    pub(super) fn label_transform_as() -> super::LabelTransformAs {
        super::LabelTransformAs::Variant0(
            super::LabelTransformAsVariant0::Variant0("x".to_string()),
            super::LabelTransformAsVariant0::Variant0("y".to_string()),
            super::LabelTransformAsVariant0::Variant0("opacity".to_string()),
            super::LabelTransformAsVariant0::Variant0("align".to_string()),
            super::LabelTransformAsVariant0::Variant0("baseline".to_string()),
        )
    }
    pub(super) fn label_transform_avoid_base_mark() -> super::LabelTransformAvoidBaseMark {
        super::LabelTransformAvoidBaseMark::Variant0(true)
    }
    pub(super) fn label_transform_line_anchor() -> super::LabelTransformLineAnchor {
        super::LabelTransformLineAnchor::Variant0("end".to_string())
    }
    pub(super) fn label_transform_method() -> super::LabelTransformMethod {
        super::LabelTransformMethod::Variant0("naive".to_string())
    }
    pub(super) fn label_transform_offset() -> super::LabelTransformOffset {
        super::LabelTransformOffset::Variant0(vec![
            super::LabelTransformOffsetVariant0Item::Variant0(1_f64),
        ])
    }
    pub(super) fn linkpath_transform_as() -> super::LinkpathTransformAs {
        super::LinkpathTransformAs::Variant0("path".to_string())
    }
    pub(super) fn linkpath_transform_orient() -> super::LinkpathTransformOrient {
        super::LinkpathTransformOrient::Variant0(super::LinkpathTransformOrientVariant0::Vertical)
    }
    pub(super) fn linkpath_transform_shape() -> super::LinkpathTransformShape {
        super::LinkpathTransformShape::Variant0(super::LinkpathTransformShapeVariant0::Line)
    }
    pub(super) fn linkpath_transform_source_x() -> super::LinkpathTransformSourceX {
        super::LinkpathTransformSourceX::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("source.x".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_source_y() -> super::LinkpathTransformSourceY {
        super::LinkpathTransformSourceY::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("source.y".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_target_x() -> super::LinkpathTransformTargetX {
        super::LinkpathTransformTargetX::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("target.x".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_target_y() -> super::LinkpathTransformTargetY {
        super::LinkpathTransformTargetY::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("target.y".to_string()),
        ))
    }
    pub(super) fn loess_transform_bandwidth() -> super::LoessTransformBandwidth {
        super::LoessTransformBandwidth::Variant0(0.3_f64)
    }
    pub(super) fn pack_transform_as() -> super::PackTransformAs {
        super::PackTransformAs::Variant0(
            super::PackTransformAsVariant0::Variant0("x".to_string()),
            super::PackTransformAsVariant0::Variant0("y".to_string()),
            super::PackTransformAsVariant0::Variant0("r".to_string()),
            super::PackTransformAsVariant0::Variant0("depth".to_string()),
            super::PackTransformAsVariant0::Variant0("children".to_string()),
        )
    }
    pub(super) fn partition_transform_as() -> super::PartitionTransformAs {
        super::PartitionTransformAs::Variant0(
            super::PartitionTransformAsVariant0::Variant0("x0".to_string()),
            super::PartitionTransformAsVariant0::Variant0("y0".to_string()),
            super::PartitionTransformAsVariant0::Variant0("x1".to_string()),
            super::PartitionTransformAsVariant0::Variant0("y1".to_string()),
            super::PartitionTransformAsVariant0::Variant0("depth".to_string()),
            super::PartitionTransformAsVariant0::Variant0("children".to_string()),
        )
    }
    pub(super) fn pie_transform_as() -> super::PieTransformAs {
        super::PieTransformAs::Variant0(
            super::PieTransformAsVariant0::Variant0("startAngle".to_string()),
            super::PieTransformAsVariant0::Variant0("endAngle".to_string()),
        )
    }
    pub(super) fn pie_transform_end_angle() -> super::PieTransformEndAngle {
        super::PieTransformEndAngle::Variant0(6.283185307179586_f64)
    }
    pub(super) fn pivot_transform_op() -> super::PivotTransformOp {
        super::PivotTransformOp::Variant0(super::PivotTransformOpVariant0::Sum)
    }
    pub(super) fn quantile_transform_as() -> super::QuantileTransformAs {
        super::QuantileTransformAs::Variant0(vec![
            super::QuantileTransformAsVariant0Item::Variant0("prob".to_string()),
            super::QuantileTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
    pub(super) fn quantile_transform_step() -> super::QuantileTransformStep {
        super::QuantileTransformStep::Variant0(0.01_f64)
    }
    pub(super) fn regression_transform_method() -> super::RegressionTransformMethod {
        super::RegressionTransformMethod::Variant0("linear".to_string())
    }
    pub(super) fn regression_transform_order() -> super::RegressionTransformOrder {
        super::RegressionTransformOrder::Variant0(3_f64)
    }
    pub(super) fn sample_transform_size() -> super::SampleTransformSize {
        super::SampleTransformSize::Variant0(1000_f64)
    }
    pub(super) fn sequence_transform_as() -> super::SequenceTransformAs {
        super::SequenceTransformAs::Variant0("data".to_string())
    }
    pub(super) fn sequence_transform_step() -> super::SequenceTransformStep {
        super::SequenceTransformStep::Variant0(1_f64)
    }
    pub(super) fn stack_transform_as() -> super::StackTransformAs {
        super::StackTransformAs::Variant0(
            super::StackTransformAsVariant0::Variant0("y0".to_string()),
            super::StackTransformAsVariant0::Variant0("y1".to_string()),
        )
    }
    pub(super) fn stack_transform_offset() -> super::StackTransformOffset {
        super::StackTransformOffset::Variant0(super::StackTransformOffsetVariant0::Zero)
    }
    pub(super) fn timeunit_transform_as() -> super::TimeunitTransformAs {
        super::TimeunitTransformAs::Variant0(
            super::TimeunitTransformAsVariant0::Variant0("unit0".to_string()),
            super::TimeunitTransformAsVariant0::Variant0("unit1".to_string()),
        )
    }
    pub(super) fn timeunit_transform_interval() -> super::TimeunitTransformInterval {
        super::TimeunitTransformInterval::Variant0(true)
    }
    pub(super) fn timeunit_transform_maxbins() -> super::TimeunitTransformMaxbins {
        super::TimeunitTransformMaxbins::Variant0(40_f64)
    }
    pub(super) fn timeunit_transform_step() -> super::TimeunitTransformStep {
        super::TimeunitTransformStep::Variant0(1_f64)
    }
    pub(super) fn timeunit_transform_timezone() -> super::TimeunitTransformTimezone {
        super::TimeunitTransformTimezone::Variant0(super::TimeunitTransformTimezoneVariant0::Local)
    }
    pub(super) fn tree_transform_as() -> super::TreeTransformAs {
        super::TreeTransformAs::Variant0(
            super::TreeTransformAsVariant0::Variant0("x".to_string()),
            super::TreeTransformAsVariant0::Variant0("y".to_string()),
            super::TreeTransformAsVariant0::Variant0("depth".to_string()),
            super::TreeTransformAsVariant0::Variant0("children".to_string()),
        )
    }
    pub(super) fn tree_transform_method() -> super::TreeTransformMethod {
        super::TreeTransformMethod::Variant0(super::TreeTransformMethodVariant0::Tidy)
    }
    pub(super) fn tree_transform_separation() -> super::TreeTransformSeparation {
        super::TreeTransformSeparation::Variant0(true)
    }
    pub(super) fn treemap_transform_as() -> super::TreemapTransformAs {
        super::TreemapTransformAs::Variant0(
            super::TreemapTransformAsVariant0::Variant0("x0".to_string()),
            super::TreemapTransformAsVariant0::Variant0("y0".to_string()),
            super::TreemapTransformAsVariant0::Variant0("x1".to_string()),
            super::TreemapTransformAsVariant0::Variant0("y1".to_string()),
            super::TreemapTransformAsVariant0::Variant0("depth".to_string()),
            super::TreemapTransformAsVariant0::Variant0("children".to_string()),
        )
    }
    pub(super) fn treemap_transform_method() -> super::TreemapTransformMethod {
        super::TreemapTransformMethod::Variant0(super::TreemapTransformMethodVariant0::Squarify)
    }
    pub(super) fn treemap_transform_ratio() -> super::TreemapTransformRatio {
        super::TreemapTransformRatio::Variant0(1.618033988749895_f64)
    }
    pub(super) fn voronoi_transform_as() -> super::VoronoiTransformAs {
        super::VoronoiTransformAs::Variant0("path".to_string())
    }
    pub(super) fn voronoi_transform_extent() -> super::VoronoiTransformExtent {
        super::VoronoiTransformExtent::Variant0(
            serde_json::from_str::<serde_json::Value>("[-100000,-100000]").unwrap(),
            serde_json::from_str::<serde_json::Value>("[100000,100000]").unwrap(),
        )
    }
    pub(super) fn window_transform_frame() -> super::WindowTransformFrame {
        super::WindowTransformFrame::Variant0(
            super::WindowTransformFrameVariant0::Variant2,
            super::WindowTransformFrameVariant0::Variant0(0_f64),
        )
    }
    pub(super) fn wordcloud_transform_as() -> super::WordcloudTransformAs {
        super::WordcloudTransformAs::Variant0(
            super::WordcloudTransformAsVariant0::Variant0("x".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("y".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("font".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("fontSize".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("fontStyle".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("fontWeight".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("angle".to_string()),
        )
    }
    pub(super) fn wordcloud_transform_font() -> super::WordcloudTransformFont {
        super::WordcloudTransformFont::Variant0("sans-serif".to_string())
    }
    pub(super) fn wordcloud_transform_font_size() -> super::WordcloudTransformFontSize {
        super::WordcloudTransformFontSize::Variant0(14_f64)
    }
    pub(super) fn wordcloud_transform_font_size_range() -> super::WordcloudTransformFontSizeRange {
        super::WordcloudTransformFontSizeRange::Variant0(vec![
            super::WordcloudTransformFontSizeRangeVariant0Item::Variant0(10_f64),
            super::WordcloudTransformFontSizeRangeVariant0Item::Variant0(50_f64),
        ])
    }
    pub(super) fn wordcloud_transform_font_style() -> super::WordcloudTransformFontStyle {
        super::WordcloudTransformFontStyle::Variant0("normal".to_string())
    }
    pub(super) fn wordcloud_transform_font_weight() -> super::WordcloudTransformFontWeight {
        super::WordcloudTransformFontWeight::Variant0("normal".to_string())
    }
}
